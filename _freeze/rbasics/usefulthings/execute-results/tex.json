{
  "hash": "5662e7245a26974cff2f8fcff37bfcbf",
  "result": {
    "markdown": "---\ntitle: \"Useful things\"\ndate: 2022-10-09\ncode-fold: false\n---\n\n\n\n\n\nThis chapter is a collection of things I wish I had known earlier in my years using R and that I hope can be of use to you. Sections are named after R packages or whatever applies and sorted alphabetically.\n\n# {broom} - tidy formatted results\n\nIn R, results from statistical tests, models etc. are often formatted in a way that may not be optimal for further processing steps. Luckily, [{broom}](https://broom.tidymodels.org/) will format the results of [the most common functions](https://broom.tidymodels.org/articles/available-methods.html) into [tidy data structures](https://www.jstatsoft.org/article/view/v059i10).\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correlation Analysis\n# for built-in example\n# data \"mtcars\"\ncor.test(mtcars$mpg, \n         mtcars$disp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\n\tPearson's product-moment correlation\n\ndata:  mtcars$mpg and mtcars$disp\nt = -8.7472, df = 30, p-value = 9.38e-10\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n -0.9233594 -0.7081376\nsample estimates:\n       cor \n-0.8475514 \n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(broom)\nlibrary(tidyverse)\n\ncor.test(mtcars$mpg,\n         mtcars$disp) %>%\n  tidy()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 1 x 8\n  estimate statistic  p.value parameter conf.low conf.high method        alter~1\n     <dbl>     <dbl>    <dbl>     <int>    <dbl>     <dbl> <chr>         <chr>  \n1   -0.848     -8.75 9.38e-10        30   -0.923    -0.708 Pearson's pr~ two.si~\n# ... with abbreviated variable name 1: alternative\n```\n:::\n:::\n\n\n:::\n:::\n\n# {dlookr} - descriptive statistics\n\nWhen providing descriptive statistics tables, one may find the number of relevant measures become annoyingly large so that even with the {tidyverse}, several lines of code are necessary. Here are just five measures, and they are not even including the [`na.rm = TRUE`](https://www.statology.org/na-rm/) argument, which is necessary for data with missing values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nPlantGrowth %>% \n  group_by(group) %>% \n  summarise(\n    mean = mean(weight),\n    stddev = sd(weight),\n    median = median(weight),\n    min = min(weight),\n    max = max(weight)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 3 x 6\n  group  mean stddev median   min   max\n  <fct> <dbl>  <dbl>  <dbl> <dbl> <dbl>\n1 ctrl   5.03  0.583   5.15  4.17  6.11\n2 trt1   4.66  0.794   4.55  3.59  6.03\n3 trt2   5.53  0.443   5.44  4.92  6.31\n```\n:::\n:::\n\n\n\nObviously, there are multiple packages who try to address just that. The one I've been using for some time now is [{dlookr}](https://choonghyunryu.github.io/dlookr/) with its `describe()` function. It actually provides more measures than I usually need[^1], but it has everything I want and I disregard the rest (via `select()`).\n\n[^1]: Keep in mind that `p00` is the 0th percentile and thus the minimum. Analogously, `p50` is the median and `p100` the maximum.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dlookr)\n\nPlantGrowth %>%\n  group_by(group) %>%\n  describe(weight)\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 3 x 27\n  described_~1 group     n    na  mean    sd se_mean   IQR skewn~2 kurto~3   p00\n  <chr>        <fct> <int> <int> <dbl> <dbl>   <dbl> <dbl>   <dbl>   <dbl> <dbl>\n1 weight       ctrl     10     0  5.03 0.583   0.184 0.743   0.321  -0.229  4.17\n2 weight       trt1     10     0  4.66 0.794   0.251 0.662   0.659  -0.203  3.59\n3 weight       trt2     10     0  5.53 0.443   0.140 0.467   0.673  -0.324  4.92\n# ... with 16 more variables: p01 <dbl>, p05 <dbl>, p10 <dbl>, p20 <dbl>,\n#   p25 <dbl>, p30 <dbl>, p40 <dbl>, p50 <dbl>, p60 <dbl>, p70 <dbl>,\n#   p75 <dbl>, p80 <dbl>, p90 <dbl>, p95 <dbl>, p99 <dbl>, p100 <dbl>, and\n#   abbreviated variable names 1: described_variables, 2: skewness, 3: kurtosis\n```\n:::\n:::\n\n\n\n# {forcats} - factor level handling\n\nIn my experience, R beginners really only care about the difference between `factor` and `character` variables once the factor level order is not as they want it to be - typically on the x-axis of a plot. Luckily, [{forcats}](https://forcats.tidyverse.org/) can deal with this.\n\nIn the following example, we create a column `fct` that is a copy of the column `chr`, except that they are formatted as `factor` and `character`, respectively.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndat <- tribble(\n     ~val,   ~chr,\n       10, \"Ctrl\", \n       15,    \"A\",\n        8,    \"B\"\n) %>% \n  mutate(fct = as.factor(chr))\n\nggplot(dat) +\n  aes(y = val, x = fct) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](usefulthings_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nEven though the data is sorted so that Ctrl is first, then A, then B, the x-Axis is sorted differently[^2]. This is because factor levels are always sorted alphabetically by default. We can reorder them via different functions in {forcats}:\n\n[^2]: It does not make a difference here, whether we put `x = chr` or `x = fct` in the ggplot statement.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- dat %>% \n  mutate(\n    fct2 = fct_relevel(fct, c(\"Ctrl\", \"A\", \"B\")),\n    fct3 = fct_reorder(fct, val, mean)\n    )\n\nstr(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\ntibble [3 x 5] (S3: tbl_df/tbl/data.frame)\n $ val : num [1:3] 10 15 8\n $ chr : chr [1:3] \"Ctrl\" \"A\" \"B\"\n $ fct : Factor w/ 3 levels \"A\",\"B\",\"Ctrl\": 3 1 2\n $ fct2: Factor w/ 3 levels \"Ctrl\",\"A\",\"B\": 1 2 3\n $ fct3: Factor w/ 3 levels \"B\",\"Ctrl\",\"A\": 2 3 1\n```\n:::\n:::\n\n\n\nAbove are just two popular examples for sorting factor levels: `fct_relevel` sorts the levels manually by providing a vector with the level names in the order they should appear, while `fct_reorder` here sorts the levels according to their respective group mean[^3] of the values in the `val` column.\n\n[^3]: Yes, the mean in this example is not really a mean, since there is only one number per group.\n\nYou can see that it worked in the output of `str(dat)` above and in the plots below.\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dat) +\n  aes(y = val, x = fct2) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](usefulthings_files/figure-pdf/unnamed-chunk-9-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dat) +\n  aes(y = val, x = fct3) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](usefulthings_files/figure-pdf/unnamed-chunk-10-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n:::\n\n# {ggtext} - automatic word wrapping\n\nAdding long text to plots created via {ggplot2} is problematic, since you have to insert line breaks yourself. However, [{ggext}](https://wilkelab.org/ggtext/)'s `geom_textbox()` for data labels and `element_textbox_simple()` for title, caption etc. will automatically add line breaks:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongtext <- \"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum.\"\n```\n:::\n\n\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot() +\n  \n  \n  \n  aes(y = 1, x = 1, label = longtext) +\n  geom_label() +\n  labs(caption = longtext)\n```\n\n::: {.cell-output-display}\n![](usefulthings_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggtext)\n\nggplot() +\n  theme(plot.caption =\n          element_textbox_simple()\n        ) +\n  aes(y = 1, x = 1, label = longtext) +\n  geom_textbox() +\n  labs(caption = longtext)\n```\n\n::: {.cell-output-display}\n![](usefulthings_files/figure-pdf/unnamed-chunk-13-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n:::\n\n# %in% and %not_in%\n\nR has the built-in function `%in%` which checks whether something is present in a vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreatments <- c(\"Ctrl\", \"A\", \"B\")\n```\n:::\n\n\n\nNot only can we checke which treatments are present in our `treatment` vector (left), but we can also easily keep only those that are (right).\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"A\", \"D\") %in% treatments \n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1]  TRUE FALSE\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"A\", \"D\") %>% .[. %in% treatments]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"A\"\n```\n:::\n:::\n\n\n:::\n:::\n\nNot built-in, for some reason, is the opposite of that function - checking whether something is **not** present. Yet, we can quickly built our own function that does exactly that:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`%not_in%` <- Negate(`%in%`)\n```\n:::\n\n\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"A\", \"D\") %not_in% treatments \n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE  TRUE\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"A\", \"D\") %>% .[. %not_in% treatments]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"D\"\n```\n:::\n:::\n\n\n:::\n:::\n\n\n\n\n",
    "supporting": [
      "usefulthings_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "\\usepackage{booktabs}\r\n\\usepackage{longtable}\r\n\\usepackage{array}\r\n\\usepackage{multirow}\r\n\\usepackage{wrapfig}\r\n\\usepackage{float}\r\n\\usepackage{colortbl}\r\n\\usepackage{pdflscape}\r\n\\usepackage{tabu}\r\n\\usepackage{threeparttable}\r\n\\usepackage{threeparttablex}\r\n\\usepackage[normalem]{ulem}\r\n\\usepackage{makecell}\r\n\\usepackage{xcolor}\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}