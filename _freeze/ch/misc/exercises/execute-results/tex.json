{
  "hash": "9663d87628b3d6859a2481643a152405",
  "result": {
    "markdown": "---\ntitle: \"Exercises\"\ncode-fold: true\nnumber-sections: true\nnumber-depth: 1\nexecute:\n  echo: true\n  output: false\n---\n\n\n\n# Ex: 1wCRD\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Exercise\"}\n# This data holds information about the misture content from multiple samples\n# for each of four different soils. Notice that for this dataset you have no\n# information on any specific field trial layout (i.e. row or col column are\n# not present in the dataset). Therefore you should skip trying to create a\n# field layout with desplot() and instead focus on the following:\n# 1) How many samples per soil were taken?\n# 2) Which soil has the highest value for moisture?\n# 3) Which soil has the highest average value for moisture?\n# 4) Create a ggplot with moisture values per soil!\n# 5) Conduct an ANOVA\n# 6) Perform multiple mean comparisons using the LSD test/t-test.\n# Bonus:\n# 7) Repeat the analysis, but this time remove all moisture values larger than\n# 12 at the very beginning.\n\n# get data\nlibrary(tidyverse)\npath <- \"https://raw.githubusercontent.com/SchmidtPaul/dsfair_quarto/master/data/Mead1993b.csv\"\ndat_1wCRD <- read_csv(path, col_types = \"fn\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Solution\"}\nlibrary(emmeans)\nlibrary(multcomp)\nlibrary(multcompView)\n\ndat_1wCRD %>% \n  group_by(soil) %>% \n  summarise(\n    n = n(),\n    max = max(moisture),\n    mean = mean(moisture)\n  )\n\nplot_1wCRD <- ggplot(data = dat_1wCRD) +\n  aes(y = moisture, x = soil) +\n  geom_point() +\n  theme_bw() +\n  scale_y_continuous(\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.05))\n  )\n\nmod_1wCRD <- lm(moisture ~ soil, dat_1wCRD)\n\nanova(mod_1wCRD)\n  \nmod_1wCRD %>% \n  emmeans(specs = ~ soil) %>%\n  cld(adjust = \"none\", Letters = letters) \n```\n:::\n\n\n\n# Ex: 1wRCBD\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Exercise\"}\n# This data holds information from a yield (t/ha) trial laid out as a\n# randomized complete block design (3 blocks) with cultivar (4 cultivars)\n# being the only treatment factor. Thus, we have a total of 12 plots.\n# 1) Create a desplot!\n# 2) Which cultivar has the highest average yield?\n# 3) Which block has the highest average yield?\n# 4) Create a ggplot with yield per cultivar.\n# 5) Conduct an ANOVA\n# 6) Perform multiple mean comparisons using the t-test.\n# Bonus:\n# 7) Repeat the analysis, but this time remove all observations from block 1.\n\n# get data\nlibrary(tidyverse)\npath <- \"https://raw.githubusercontent.com/SchmidtPaul/dsfair_quarto/master/data/Clewer&Scarisbrick2001.csv\"\ndat_1wRCBD <- read_csv(path, col_types = \"ffnii\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Solution\"}\nlibrary(emmeans)\nlibrary(desplot)\nlibrary(multcomp)\nlibrary(multcompView)\n\nmydp <- desplot(\n  data = dat_1wRCBD,\n  flip = TRUE, \n  form = cultivar ~ col + row,\n  text = cultivar,\n  out1 = block,\n  cex = 1,\n  show.key = FALSE\n)\n\ndat_1wRCBD %>% \n  group_by(cultivar) %>% \n  summarise(mean = mean(yield))\n\ndat_1wRCBD %>% \n  group_by(block) %>% \n  summarise(mean = mean(yield))\n\nplot_1wRCBD <- ggplot(data = dat_1wRCBD) +\n  aes(y = yield, x = cultivar, color = block) +\n  geom_point() +\n  theme_bw() +\n  scale_y_continuous(\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.05))\n  )\n\nmod_1wRCBD <- lm(yield ~ cultivar + block, dat_1wRCBD)\n\nanova(mod_1wRCBD)\n  \nmod_1wRCBD %>% \n  emmeans(specs = ~ cultivar) %>%\n  cld(adjust = \"none\", Letters = letters) \n```\n:::\n\n\n\n# Ex: 1wAugLat\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Exercise\"}\n# This dataset contains information from an experiment utilizing a resolvable\n# design with checks. Specifically, it features 2 replicates and includes 90\n# unique entries. Additionally, there are 6 checks with extra replication.\n# Each block in the design contains 10 entries, and these incomplete blocks\n# are organized according to a lattice design, which allows them to be grouped\n# into complete replicates, forming a resolvable design structure. In this\n# dataset, standards are coded from 1001 to 1006, while the entries are coded\n# from 2 to 100.\n# 1) Create a desplot!\n# 2) What is the the number of missing values, the number of non-missing\n# values and the average value for yield for each combination of rep and\n# genoCheck?\n# 3) Create a ggplot with geno on the x-axis, yield on the y-axis and\n# dots colored depending on whether a geno is a check or not!\n# 4) Compare the average s.e.d. to find out whether the effects for\n# incomplete blocks should be taken as fixed or random in the model!\n# 5) Conduct an ANOVA\n# 6) Perform multiple mean comparisons using the t-test.\n\n# get data\nlibrary(tidyverse)\npath <- \"https://raw.githubusercontent.com/SchmidtPaul/dsfair_quarto/master/data/PiephoAugmentedLattice.csv\"\ndat_1wAugLat <- read_csv(path, col_types = \"ffffnnii\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Solution\"}\nlibrary(emmeans)\nlibrary(desplot)\nlibrary(lme4)\nlibrary(lmerTest)\nlibrary(multcomp)\nlibrary(multcompView)\n\nmydp <- desplot(\n  data = dat_1wAugLat,\n  flip = TRUE, \n  form = geno ~ col + row,\n  text = geno,\n  col = genoCheck, \n  col.text = c(\"red\", \"black\"),\n  out1 = rep,\n  out2 = block, \n  show.key = FALSE\n)\n\ndat_1wAugLat %>%\n  group_by(rep, genoCheck) %>%\n  summarise(nobs = sum(!is.na(yield)),\n            nNA  = sum(is.na(yield)),\n            mean = mean(yield, na.rm = TRUE))\n\ngeno_order <- dat_1wAugLat %>% \n  group_by(geno) %>% \n  summarise(mean = mean(yield, na.rm = TRUE)) %>% \n  ungroup() %>% \n  arrange(mean) %>% \n  pull(geno) %>% \n  as.character()\n\nmygg <- ggplot(data = dat_1wAugLat) +\n  aes(y = yield, x = geno, color = genoCheck) +\n  geom_point() +\n  theme_bw() +\n  scale_y_continuous(\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_x_discrete(\n    limits = geno_order\n  )\n\nmod_1wAugLat_fb <-   lm(yield ~ geno + rep + block,       data = dat_1wAugLat)\nmod_1wAugLat_rb <- lmer(yield ~ geno + rep + (1 | block), data = dat_1wAugLat)\n\nmod_1wAugLat_fb %>%\n  emmeans(pairwise ~ \"geno\",\n          adjust = \"none\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean() # get arithmetic mean\n\n# this takes some time!\nmod_1wAugLat_rb %>%\n  emmeans(pairwise ~ \"geno\",\n          adjust = \"none\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean() # get arithmetic mean\n\nanova(mod_1wAugLat_rb)\n  \nmod_1wAugLat_rb %>% \n  emmeans(specs = ~ geno) %>%\n  cld(adjust = \"none\", Letters = letters) \n```\n:::\n\n\n\n# Ex: 1wRowCol\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Exercise\"}\n# This data contains information from an experiment involving 64 oat\n# genotypes. The experimental design is an 8 x 8 lattice, which has been\n# replicated three times.\n# 1) Create a desplot!\n# 2) Per replicate, what is the the number of missing values, the number of\n# non-missing values and the average value for yield, height and TKW,\n# respectively?\n# 3) Create a ggplot with treat on the x-axis, yield on the y-axis!\n# 4) Compare the average s.e.d. to find out whether the effects for\n# incomplete blocks should be taken as fixed or random in the model!\n# 5) Conduct an ANOVA\n# 6) Perform multiple mean comparisons using the t-test.\n\n# get data\nlibrary(tidyverse)\npath <- \"https://raw.githubusercontent.com/SchmidtPaul/dsfair_quarto/master/data/RowColFromUtz.csv\"\ndat_1wRowCol <- read_csv(path, col_types = \"fiiffnnn\") %>% \n  mutate(rowF = as.factor(row), colF = as.factor(col))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-summary=\"Solution\"}\nlibrary(emmeans)\nlibrary(lme4)\nlibrary(lmerTest)\nlibrary(multcomp)\nlibrary(multcompView)\n\nmydp <- desplot(\n  data = dat_1wRowCol,\n  flip = TRUE, \n  form = treat ~ col + row,\n  text = treat,\n  out1 = rep,\n  out2 = inc_block, \n  show.key = FALSE\n)\n\ndat_1wRowCol %>%\n  group_by(rep) %>%\n  dlookr::describe(yield, height, TKW) %>% \n  dplyr::select(1:sd)\n\ntreat_order <- dat_1wRowCol %>% \n  group_by(treat) %>% \n  summarise(mean = mean(yield, na.rm = TRUE)) %>% \n  ungroup() %>% \n  arrange(mean) %>% \n  pull(treat) %>% \n  as.character()\n\nmygg <- ggplot(data = dat_1wRowCol) +\n  aes(y = yield, x = treat) +\n  geom_point() +\n  theme_bw() +\n  scale_y_continuous(\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_x_discrete(\n    limits = treat_order\n  )\n\nmod_1wRowCol_fb <-   lm(yield ~ treat + rep + inc_block,       data = dat_1wRowCol)\nmod_1wRowCol_rb <- lmer(yield ~ treat + rep + (1 | inc_block), data = dat_1wRowCol)\n\nmod_1wRowCol_fb %>%\n  emmeans(pairwise ~ \"treat\",\n          adjust = \"none\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean() # get arithmetic mean\n\n# this takes some time!\nmod_1wRowCol_rb %>%\n  emmeans(pairwise ~ \"treat\",\n          adjust = \"none\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean() # get arithmetic mean\n\nanova(mod_1wRowCol_rb)\n  \nmod_1wRowCol_rb %>% \n  emmeans(specs = ~ treat) %>%\n  cld(adjust = \"none\", Letters = letters) \n```\n:::\n",
    "supporting": [
      "exercises_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}