{
  "hash": "a394c1d346b550289df27b361a90563e",
  "result": {
    "markdown": "---\ntitle: \"One-way row column design\"\nabstract: \"One-way ANOVA & pairwise comparison post hoc tests in a resolvable row column design.\"\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (install &) load packages\npacman::p_load(\n  conflicted,\n  desplot,\n  emmeans,\n  ggtext,\n  lme4,\n  lmerTest,\n  multcomp,\n  multcompView,\n  tidyverse)\n\n# handle function conflicts\nconflicts_prefer(dplyr::filter) \nconflicts_prefer(dplyr::select)\nconflicts_prefer(lmerTest::lmer)\n```\n:::\n\n\n\n# Data\n\nThis example is taken from Chapter *\"3.10 Analysis of a resolvable row-column design\"* of the course material \"Mixed models for metric data (3402-451)\" by [Prof. Dr. Hans-Peter Piepho](https://www.uni-hohenheim.de/organisation?tx_base_lsfcontentadmin%5BlsfPerson%5D=6257). It considers data published in @kemptonfox_1996 from a yield trial laid out as a resolvable row-column design. The trial had 35 genotypes (`gen`), 2 complete replicates (`rep`) with 5 rows (`row`) and 7 columns (`col`). Thus, a complete replicate is subdivided into incomplete rows and columns.\n\n## Import\n\nThe data is available as part of the {agridat} package:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- as_tibble(agridat::kempton.rowcol)\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 68 x 5\n   rep     row   col gen   yield\n   <fct> <int> <int> <fct> <dbl>\n 1 R1        1     1 G20    3.77\n 2 R1        1     2 G04    3.21\n 3 R1        1     3 G33    4.55\n 4 R1        1     4 G28    4.09\n 5 R1        1     5 G07    5.05\n 6 R1        1     6 G12    4.19\n 7 R1        1     7 G30    3.27\n 8 R1        2     1 G10    3.44\n 9 R1        2     2 G14    4.3 \n10 R1        2     4 G21    3.86\n# i 58 more rows\n```\n:::\n:::\n\n\n\n## Format\n\nFor our analysis, `gen`, `row` and `col` should be encoded as factors. However, the `desplot()` function needs `row` and `col` as formatted as integers. Therefore we create copies of these columns encoded as factors and named `rowF` and `colF`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- dat %>%\n  mutate(\n    colF = as.factor(col),\n    rowF = as.factor(row)\n  )\n```\n:::\n\n\n\n## Explore\n\nWe make use of [`dlookr::describe()`](../../misc/usefulthings.qmd#dlookr) to conveniently obtain descriptive summary tables. Here, we get can summarize per block and per cultivar.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  group_by(gen) %>% \n  dlookr::describe(yield) %>% \n  select(2:sd) %>%\n  arrange(desc(mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 35 x 5\n   gen       n    na  mean     sd\n   <fct> <int> <int> <dbl>  <dbl>\n 1 G19       2     0  6.07 1.84  \n 2 G07       2     0  5.74 0.976 \n 3 G33       2     0  5.13 0.820 \n 4 G06       2     0  4.96 0.940 \n 5 G09       2     0  4.94 1.68  \n 6 G11       2     0  4.93 1.03  \n 7 G14       2     0  4.92 0.877 \n 8 G27       2     0  4.89 1.80  \n 9 G03       2     0  4.78 0.0424\n10 G25       2     0  4.78 0.361 \n# i 25 more rows\n```\n:::\n:::\n\n\n\nAdditionally, we can decide to plot our data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# sort genotypes by mean yield\ngen_order <- dat %>% \n  group_by(gen) %>% \n  summarise(mean = mean(yield, na.rm = TRUE)) %>% \n  arrange(mean) %>% \n  pull(gen) %>% \n  as.character()\n\nggplot(data = dat) +\n  aes(\n    y = yield,\n    x = gen,\n    shape = rep\n  ) +\n  geom_line(\n    aes(group = gen),\n    color = \"darkgrey\"\n  ) +\n  geom_point() +\n  scale_x_discrete(\n    name = \"Genotype\",\n    limits = gen_order\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_shape_discrete(\n    name = \"Replicate\"\n  ) +\n  guides(shape = guide_legend(nrow = 1)) +\n  theme_classic() +\n  theme(\n    legend.position = \"top\", \n    axis.text.x = element_text(angle = 90, vjust = 0.5)\n  )\n```\n\n::: {.cell-output-display}\n![](rowcol_kemptonfox1997_files/figure-pdf/unnamed-chunk-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nFinally, since this is an experiment that was laid with a certain experimental design (= a resolvable row column design) - it makes sense to also get a field plan. This can be done via `desplot()` from [{desplot}](../../misc/usefulthings.qmd#desplot). In this case it is worth noting that there is missing data, as yield values for two plots are not present in the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndesplot(\n  data = dat,\n  form = gen ~ col + row | rep, # fill color per genotype, headers per replicate\n  text = gen, \n  cex = 0.7, \n  shorten = \"no\",\n  out1 = row, out1.gpar=list(col=\"black\"), # lines between rows\n  out2 = col, out2.gpar=list(col=\"black\"), # lines between columns\n  main = \"Field layout\", \n  show.key = FALSE\n)     \n```\n\n::: {.cell-output-display}\n![](rowcol_kemptonfox1997_files/figure-pdf/unnamed-chunk-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n# Model\n\nFinally, we can decide to fit a linear model with `yield` as the response variable and `gen` as fixed effects, since our goal is to compare them to each other. Since the trial was laid out in rows and columns, we also need `rowF` and `colF` effects in the model, but these can be taken either as a fixed or as random effects. Since our goal is to compare genotypes, we will determine which of the two models we prefer by comparing the average standard error of a difference (s.e.d.) for the comparisons between adjusted genotype means - the lower the s.e.d. the better. \n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# blocks as fixed (linear model)\nmod_frc <- lm(yield ~ gen + rep + rowF + colF,\n             data = dat)\n\navg_sed_mod_frc <- mod_frc %>%\n  emmeans(pairwise ~ \"gen\",\n          adjust = \"none\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean() # get arithmetic mean\n\navg_sed_mod_frc\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0.4828268\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# blocks as random (linear mixed model)\nmod_rrc <- lmer(yield ~ gen + rep + (1 | rowF) + (1 | colF),\n                data = dat)\n\navg_sed_mod_rrc <- mod_rrc %>%\n  emmeans(pairwise ~ \"gen\",\n          adjust = \"none\",\n          lmer.df = \"kenward-roger\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean() # get arithmetic mean\n\navg_sed_mod_rrc\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0.4834463\n```\n:::\n:::\n\n\n:::\n:::\n\nAs a result, we find that the model with fixed row and column effects has the slightly smaller s.e.d. and is therefore more precise in terms of comparing genotypes.\n\n::: {.callout-warning collapse=\"true\"}\n## Model assumptions met? (click to show)\n\nIt would be at this moment (i.e. after fitting the model and before running the ANOVA), that you should check whether the model assumptions are met. Find out more in the [summary article \"Model Diagnostics\"](../../summaryarticles/modeldiagnostics.qmd)\n:::\n\n# ANOVA\n\nBased on our model, we can then conduct an ANOVA:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nANOVA <- anova(mod_frc)\nANOVA\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nAnalysis of Variance Table\n\nResponse: yield\n          Df Sum Sq Mean Sq  F value    Pr(>F)    \ngen       34 32.157  0.9458   5.6767 3.505e-05 ***\nrep        1 24.901 24.9014 149.4615 2.778e-11 ***\nrowF       4  1.436  0.3591   2.1553  0.107861    \ncolF       6  4.794  0.7990   4.7956  0.002873 ** \nResiduals 22  3.665  0.1666                       \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\n\nAccordingly, the ANOVA's F-test did not find the cultivar effects to be statistically significant (p < .001\\*\\*\\*).\n\n# Mean comparison\n\nBesides an ANOVA, one may also want to compare adjusted yield means between cultivars via post hoc tests (t-test, Tukey test etc.).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_comp <- mod_frc %>% \n  emmeans(specs = ~ gen) %>% # adj. mean per genotype\n  cld(adjust = \"none\", Letters = letters) # compact letter display (CLD)\n\nmean_comp\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n gen emmean    SE df lower.CL upper.CL .group       \n G15   3.29 0.475 22     2.31     4.28  ab          \n G04   3.35 0.326 22     2.67     4.03  a           \n G23   3.54 0.323 22     2.87     4.21  ab          \n G29   3.57 0.323 22     2.90     4.25  ab          \n G16   3.59 0.470 22     2.61     4.56  abcde       \n G26   3.63 0.350 22     2.90     4.35  abc         \n G02   3.71 0.347 22     2.99     4.43  abcd        \n G22   3.79 0.327 22     3.12     4.47  abcde       \n G24   3.82 0.351 22     3.09     4.54  abcdef      \n G31   3.82 0.322 22     3.15     4.49  abcdef      \n G35   3.94 0.324 22     3.27     4.61  abcdefg     \n G17   4.07 0.326 22     3.39     4.75  abcdefgh    \n G28   4.12 0.320 22     3.45     4.78  abcdefgh    \n G32   4.15 0.347 22     3.43     4.87  abcdefgh    \n G30   4.18 0.352 22     3.45     4.91  abcdefgh    \n G09   4.24 0.352 22     3.51     4.98  abcdefghi   \n G25   4.28 0.326 22     3.60     4.95   bcdefghi   \n G34   4.30 0.349 22     3.58     5.03   bcdefghij  \n G20   4.32 0.337 22     3.62     5.02   bcdefghij  \n G10   4.56 0.323 22     3.90     5.23    cdefghij  \n G05   4.60 0.325 22     3.93     5.28     defghijk \n G14   4.61 0.322 22     3.94     5.28    cdefghij  \n G13   4.66 0.322 22     3.99     5.32    cdefghij  \n G11   4.69 0.347 22     3.98     5.41     defghijk \n G08   4.70 0.326 22     4.03     5.38      efghij  \n G21   4.75 0.344 22     4.04     5.47     defghijk \n G27   4.80 0.323 22     4.13     5.48       fghijkl\n G18   4.84 0.322 22     4.18     5.51        ghijkl\n G33   4.88 0.325 22     4.21     5.56        ghijkl\n G01   4.88 0.343 22     4.17     5.60        ghijkl\n G12   4.98 0.322 22     4.31     5.65         hijkl\n G03   5.20 0.321 22     4.53     5.86          ijkl\n G07   5.21 0.323 22     4.54     5.88           jkl\n G06   5.59 0.326 22     4.92     6.27            kl\n G19   5.73 0.326 22     5.06     6.41             l\n\nResults are averaged over the levels of: rep, rowF, colF \nConfidence level used: 0.95 \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n:::\n:::\n\n\n\nIt can be seen that the compact letter display is kind of reaching its limit as the way differences are found to be statistically significant here is quite complex.\n\nNote that if you would like to see the underlying individual contrasts/differences between adjusted means, simply add `details = TRUE` to the `cld()` statement. Furthermore, check out the [Summary Article \"Compact Letter Display\"](../../summaryarticles/compactletterdisplay.qmd).\n\nFinally, we can create a plot that displays both the raw data and the results, *i.e.* the comparisons of the adjusted means that are based on the linear model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# reorder genotype factor levels according to adjusted mean\nmy_caption <- \"Black dots represent raw data. Red diamonds and error bars represent adjusted means with 95% confidence limits per cultivar. Means followed by a common letter are not significantly different according to the t-test.\"\n\nggplot() +\n  # green/red dots representing the raw data\n  geom_point(\n    data = dat,\n    aes(y = yield, x = gen)\n  ) +\n  # red diamonds representing the adjusted means\n  geom_point(\n    data = mean_comp,\n    aes(y = emmean, x = gen),\n    shape = 18,\n    color = \"red\",\n    position = position_nudge(x = 0.2)\n  ) +\n  # red error bars representing the confidence limits of the adjusted means\n  geom_errorbar(\n    data = mean_comp,\n    aes(ymin = lower.CL, ymax = upper.CL, x = gen),\n    color = \"red\",\n    width = 0.1,\n    position = position_nudge(x = 0.2)\n  ) +\n  # red letters \n  geom_text(\n    data = mean_comp,\n    aes(y = upper.CL, x = gen, label = str_trim(.group)),\n    color = \"red\",\n    angle = 90,\n    hjust = -0.2,\n    position = position_nudge(x = 0.2)\n  ) + \n  scale_x_discrete(\n    name = \"Cultivar\",\n    limits = as.character(mean_comp$gen)\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    # limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  coord_cartesian(ylim = c(0, NA)) +\n  labs(caption = my_caption) +\n  theme_classic() +\n  theme(plot.caption = element_textbox_simple(margin = margin(t = 5)),\n        plot.caption.position = \"plot\",\n        axis.text.x = element_text(angle = 90, vjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](rowcol_kemptonfox1997_files/figure-pdf/unnamed-chunk-12-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n# Bonus\n\nHere are some other things you would maybe want to look at for the analysis of this dataset.\n\n## Variance components\n\nTo extract variance components from our models, we unfortunately need different functions per model since only of of them is a mixed model and we used different functions to fit them.\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Residual Variance\nsummary(mod_frc)$sigma^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0.1666074\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Both Variance Components\nas_tibble(VarCorr(mod_rrc))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 3 x 5\n  grp      var1        var2    vcov sdcor\n  <chr>    <chr>       <chr>  <dbl> <dbl>\n1 colF     (Intercept) <NA>  0.144  0.380\n2 rowF     (Intercept) <NA>  0.0293 0.171\n3 Residual <NA>        <NA>  0.167  0.409\n```\n:::\n:::\n\n\n:::\n:::\n\n## Efficiency\n\nThe *efficiency of a resolvable design* can be calculated as its mean s.e.d. compared to the (mean[^1]) s.e.d. of the analogous RCBD, i.e. leaving out the incomplete block effects within the replicates. Above, we have already calculated the mean s.e.d. of our resolvable design so we can square it and get `avg_sed_mod_frc^2` which is 0.23312. Accordingly, we can fit a model leaving out the incomplete block effects and get the s.e.d. just like before and also square it:\n\n[^1]: In this scenario, all s.e.d. of the RCBD model would be identical so we don't really need to get the average, but could instead argue that there is only one constant s.e.d.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_sed_mod_RCBD <- lm(yield ~ gen + rep, data = dat) %>% \n  emmeans(pairwise ~ \"gen\",\n          adjust = \"none\",\n          lmer.df = \"kenward-roger\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean()\n\navg_sed_mod_RCBD^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0.3257469\n```\n:::\n:::\n\n\n\nFinally, the efficiency of this resolvable design is then\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_sed_mod_RCBD^2 / avg_sed_mod_frc^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1.397325\n```\n:::\n:::\n\n\n\nmeaning that the resolvable design is more efficient since the efficiency is > 1.\n",
    "supporting": [
      "rowcol_kemptonfox1997_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "\\usepackage{booktabs}\r\n\\usepackage{longtable}\r\n\\usepackage{array}\r\n\\usepackage{multirow}\r\n\\usepackage{wrapfig}\r\n\\usepackage{float}\r\n\\usepackage{colortbl}\r\n\\usepackage{pdflscape}\r\n\\usepackage{tabu}\r\n\\usepackage{threeparttable}\r\n\\usepackage{threeparttablex}\r\n\\usepackage[normalem]{ulem}\r\n\\usepackage{makecell}\r\n\\usepackage{xcolor}\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}