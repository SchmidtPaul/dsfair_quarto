{
  "hash": "ae4e65f55264dd66416de2494a7857e1",
  "result": {
    "markdown": "---\ntitle: \"One-way alpha design\"\nabstract: \"One-way ANOVA & pairwise comparison post hoc tests in an alpha design.\"\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (install &) load packages\npacman::p_load(\n  agridat,\n  conflicted,\n  desplot,\n  emmeans,\n  ggtext,\n  lme4,\n  lmerTest,\n  multcomp,\n  multcompView,\n  tidyverse)\n\n# handle function conflicts\nconflicts_prefer(dplyr::filter) \nconflicts_prefer(dplyr::select)\nconflicts_prefer(lmerTest::lmer)\n```\n:::\n\n\n# Data\n\nThis example is taken from Chapter \"3.8 Analysis of an $\\alpha$-design\" of the course material \"Mixed models for metric data (3402-451)\" by [Prof. Dr. Hans-Peter Piepho](https://www.uni-hohenheim.de/organisation?tx_base_lsfcontentadmin%5BlsfPerson%5D=6257). It considers data published in @johnwilliams_1995 from a yield (t/ha) trial laid out as an alpha design. The trial had 24 genotypes (`gen`), 3 complete replicates (`rep`) and 6 incomplete blocks (`block`) within each replicate. The block size was 4.\n\n## Import\n\nThe data is available as part of the {agridat} package and needs no further formatting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- as_tibble(agridat::john.alpha)\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 72 × 7\n    plot rep   block gen   yield   row   col\n   <int> <fct> <fct> <fct> <dbl> <int> <int>\n 1     1 R1    B1    G11    4.12     1     1\n 2     2 R1    B1    G04    4.45     2     1\n 3     3 R1    B1    G05    5.88     3     1\n 4     4 R1    B1    G22    4.58     4     1\n 5     5 R1    B2    G21    4.65     5     1\n 6     6 R1    B2    G10    4.17     6     1\n 7     7 R1    B2    G20    4.01     7     1\n 8     8 R1    B2    G02    4.34     8     1\n 9     9 R1    B3    G23    4.23     9     1\n10    10 R1    B3    G14    4.76    10     1\n# ℹ 62 more rows\n```\n:::\n:::\n\n\n## Explore\n\nWe make use of [`dlookr::describe()`](../../misc/usefulthings.qmd#dlookr) to conveniently obtain descriptive summary tables. Here, we get can summarize per block and per cultivar.\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  group_by(gen) %>% \n  dlookr::describe(yield) %>% \n  select(2:n, mean, sd) %>%\n  arrange(desc(n), desc(mean)) %>% \n  print(n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 24 × 4\n   gen       n  mean     sd\n   <fct> <int> <dbl>  <dbl>\n 1 G01       3  5.16 0.534 \n 2 G05       3  5.06 0.841 \n 3 G12       3  4.91 0.641 \n 4 G15       3  4.89 0.207 \n 5 G19       3  4.87 0.398 \n 6 G13       3  4.83 0.619 \n 7 G21       3  4.82 0.503 \n 8 G17       3  4.73 0.379 \n 9 G16       3  4.73 0.502 \n10 G06       3  4.71 0.464 \n11 G22       3  4.64 0.432 \n12 G14       3  4.56 0.186 \n13 G02       3  4.51 0.574 \n14 G18       3  4.44 0.587 \n15 G04       3  4.40 0.0433\n16 G10       3  4.39 0.450 \n17 G11       3  4.38 0.641 \n18 G08       3  4.32 0.584 \n19 G24       3  4.14 0.726 \n20 G23       3  4.14 0.232 \n21 G07       3  4.13 0.510 \n22 G20       3  3.78 0.209 \n23 G09       3  3.61 0.606 \n24 G03       3  3.34 0.456 \n```\n:::\n:::\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  group_by(rep, block) %>% \n  dlookr::describe(yield) %>% \n  select(2:n, mean, sd) %>%\n  arrange(desc(mean)) %>% \n  print(n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 18 × 5\n   rep   block     n  mean     sd\n   <fct> <fct> <int> <dbl>  <dbl>\n 1 R2    B3        4  5.22 0.149 \n 2 R2    B5        4  5.21 0.185 \n 3 R2    B6        4  5.11 0.323 \n 4 R2    B4        4  5.01 0.587 \n 5 R1    B5        4  4.79 0.450 \n 6 R1    B1        4  4.75 0.772 \n 7 R1    B6        4  4.58 0.819 \n 8 R3    B1        4  4.38 0.324 \n 9 R1    B3        4  4.36 0.337 \n10 R1    B4        4  4.33 0.727 \n11 R3    B3        4  4.30 0.0710\n12 R1    B2        4  4.29 0.273 \n13 R2    B2        4  4.23 0.504 \n14 R3    B4        4  4.22 0.375 \n15 R3    B5        4  4.15 0.398 \n16 R2    B1        4  4.12 0.411 \n17 R3    B2        4  3.96 0.631 \n18 R3    B6        4  3.61 0.542 \n```\n:::\n:::\n\n:::\n:::\n\nAdditionally, we can decide to plot our data:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# sort genotypes by mean yield\ngen_order <- dat %>% \n  group_by(gen) %>% \n  summarise(mean = mean(yield)) %>% \n  arrange(mean) %>% \n  pull(gen) %>% \n  as.character()\n\nggplot(data = dat) +\n  aes(\n    y = yield,\n    x = gen,\n    shape = rep\n  ) +\n  geom_line(\n    aes(group = gen),\n    color = \"darkgrey\"\n  ) +\n  geom_point() +\n  scale_x_discrete(\n    name = \"Genotype\",\n    limits = gen_order\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_shape_discrete(\n    name = \"Block\"\n  ) +\n  guides(shape = guide_legend(nrow = 1)) +\n  theme_classic() +\n  theme(\n    legend.position = \"top\", \n    axis.text.x = element_text(angle = 90, vjust = 0.5)\n  )\n```\n\n::: {.cell-output-display}\n![](alpha_johnwilliams1995_files/figure-html/unnamed-chunk-6-1.png){width=1650}\n:::\n:::\n\n\nFinally, since this is an experiment that was laid with a certain experimental design (= a non-resolvable augmented design) - it makes sense to also get a field plan. This can be done via `desplot()` from [{desplot}](../../misc/usefulthings.qmd#desplot).\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndesplot(\n  data = dat, \n  flip = TRUE, # row 1 on top, not on bottom\n  form = gen ~ row + col | rep, # fill color per genotype, headers per replicate\n  out1 = block, # lines between incomplete blocks\n  out1.gpar = list(col = \"black\", lwd = 1, lty = \"dashed\"), # line type\n  main = \"Field layout\", # title\n  key.cex = 0.6,\n  layout = c(3, 1) # force all reps drawn in one row\n)\n```\n\n::: {.cell-output-display}\n![](alpha_johnwilliams1995_files/figure-html/unnamed-chunk-7-1.png){width=1650}\n:::\n:::\n\n\n# Modelling\n\nFinally, we can decide to fit a linear model with `yield` as the response variable and (fixed) `gen` and `block` effects. There also needs to be term for the 18 incomplete blocks (*i.e.* `rep:block`) in the model, but it can be taken either as a fixed or a random effect. Since our goal is to compare genotypes, we will determine which of the two models we prefer by comparing the average standard error of a difference (s.e.d.) for the comparisons between adjusted genotype means - the lower the s.e.d. the better.\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# blocks as fixed (linear model)\nmod_fb <- lm(yield ~ gen + rep +\n               rep:block,\n             data = dat)\n\navg_sed_mod_fb <- mod_fb %>%\n  emmeans(pairwise ~ \"gen\",\n          adjust = \"none\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean() # get arithmetic mean\n\navg_sed_mod_fb\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0.2766288\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# blocks as random (linear mixed model)\nmod_rb <- lmer(yield ~ gen + rep +\n                 (1 | rep:block),\n               data = dat)\n\navg_sed_mod_rb <- mod_rb %>%\n  emmeans(pairwise ~ \"gen\",\n          adjust = \"none\",\n          lmer.df = \"kenward-roger\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean() # get arithmetic mean\n\navg_sed_mod_rb\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0.2700388\n```\n:::\n:::\n\n:::\n:::\n\nAs a result, we find that the model with random block effects has the smaller s.e.d. and is therefore more precise in terms of comparing genotypes.\n\n::: {.callout-warning collapse=\"true\"}\n## Model assumptions met? (click to show)\n\nIt would be at this moment (i.e. after fitting the model and before running the ANOVA), that you should check whether the model assumptions are met. Find out more in the [summary article \"Model Diagnostics\"](../../summaryarticles/modeldiagnostics.qmd)\n:::\n\n# ANOVA\n\nBased on our model, we can then conduct an ANOVA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nANOVA <- anova(mod_rb, ddf = \"Kenward-Roger\")\nANOVA\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nType III Analysis of Variance Table with Kenward-Roger's method\n     Sum Sq Mean Sq NumDF  DenDF F value    Pr(>F)    \ngen 10.5070 0.45683    23 35.498  5.3628 4.496e-06 ***\nrep  1.5703 0.78513     2 11.519  9.2124  0.004078 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\nAccordingly, the ANOVA's F-test found the cultivar effects to be statistically significant (p < .001\\*\\*\\*).\n\n# Mean comparison\n\nBesides an ANOVA, one may also want to compare adjusted yield means between cultivars via post hoc tests (t-test, Tukey test etc.).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_comp <- mod_rb %>% \n  emmeans(specs = ~ gen) %>% # adj. mean per genotype\n  cld(adjust = \"none\", Letters = letters) # compact letter display (CLD)\n\nmean_comp\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n gen emmean    SE   df lower.CL upper.CL .group    \n G03   3.50 0.199 44.3     3.10     3.90  a        \n G09   3.50 0.199 44.3     3.10     3.90  ab       \n G20   4.04 0.199 44.3     3.64     4.44   bc      \n G07   4.11 0.199 44.3     3.71     4.51    cd     \n G24   4.15 0.199 44.3     3.75     4.55    cd     \n G23   4.25 0.199 44.3     3.85     4.65    cde    \n G11   4.28 0.199 44.3     3.88     4.68    cde    \n G18   4.36 0.199 44.3     3.96     4.76    cdef   \n G10   4.37 0.199 44.3     3.97     4.77    cdef   \n G02   4.48 0.199 44.3     4.08     4.88    cdefg  \n G04   4.49 0.199 44.3     4.09     4.89    cdefg  \n G22   4.53 0.199 44.3     4.13     4.93    cdefgh \n G08   4.53 0.199 44.3     4.13     4.93    cdefgh \n G06   4.54 0.199 44.3     4.14     4.94    cdefgh \n G17   4.60 0.199 44.3     4.20     5.00     defghi\n G16   4.73 0.199 44.3     4.33     5.13      efghi\n G12   4.76 0.199 44.3     4.35     5.16      efghi\n G13   4.76 0.199 44.3     4.36     5.16      efghi\n G14   4.78 0.199 44.3     4.37     5.18      efghi\n G21   4.80 0.199 44.3     4.39     5.20      efghi\n G19   4.84 0.199 44.3     4.44     5.24       fghi\n G15   4.97 0.199 44.3     4.57     5.37        ghi\n G05   5.04 0.199 44.3     4.64     5.44         hi\n G01   5.11 0.199 44.3     4.71     5.51          i\n\nResults are averaged over the levels of: rep \nDegrees-of-freedom method: kenward-roger \nConfidence level used: 0.95 \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n:::\n:::\n\n\nNote that if you would like to see the underlying individual contrasts/differences between adjusted means, simply add `details = TRUE` to the `cld()` statement. Furthermore, check out the [Summary Article \"Compact Letter Display\"](../../summaryarticles/compactletterdisplay.qmd).\n\nFinally, we can create a plot that displays both the raw data and the results, *i.e.* the comparisons of the adjusted means that are based on the linear model.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# reorder genotype factor levels according to adjusted mean\nmy_caption <- \"Black dots represent raw data. Red diamonds and error bars represent adjusted means with 95% confidence limits per cultivar. Means followed by a common letter are not significantly different according to the t-test.\"\n\nggplot() +\n  # green/red dots representing the raw data\n  geom_point(\n    data = dat,\n    aes(y = yield, x = gen)\n  ) +\n  # red diamonds representing the adjusted means\n  geom_point(\n    data = mean_comp,\n    aes(y = emmean, x = gen),\n    shape = 18,\n    color = \"red\",\n    position = position_nudge(x = 0.2)\n  ) +\n  # red error bars representing the confidence limits of the adjusted means\n  geom_errorbar(\n    data = mean_comp,\n    aes(ymin = lower.CL, ymax = upper.CL, x = gen),\n    color = \"red\",\n    width = 0.1,\n    position = position_nudge(x = 0.2)\n  ) +\n  # red letters \n  geom_text(\n    data = mean_comp,\n    aes(y = lower.CL, x = gen, label = str_trim(.group)),\n    color = \"red\",\n    angle = 90,\n    hjust = 1.1,\n    position = position_nudge(x = 0.2)\n  ) + \n  scale_x_discrete(\n    name = \"Cultivar\",\n    limits = as.character(mean_comp$gen)\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  labs(caption = my_caption) +\n  theme_classic() +\n  theme(plot.caption = element_textbox_simple(margin = margin(t = 5)),\n        plot.caption.position = \"plot\",\n        axis.text.x = element_text(angle = 90, vjust = 0.5))\n```\n\n::: {.cell-output-display}\n![](alpha_johnwilliams1995_files/figure-html/unnamed-chunk-12-1.png){width=1650}\n:::\n:::\n\n\n# Bonus\n\nHere are some other things you would maybe want to look at for the analysis of this dataset.\n\n## Variance components\n\nTo extract variance components from our models, we unfortunately need different functions per model since only of of them is a mixed model and we used different functions to fit them.\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Residual Variance\nsummary(mod_fb)$sigma^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0.08346307\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Both Variance Components\nas_tibble(VarCorr(mod_rb))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 2 × 5\n  grp       var1        var2    vcov sdcor\n  <chr>     <chr>       <chr>  <dbl> <dbl>\n1 rep:block (Intercept) <NA>  0.0619 0.249\n2 Residual  <NA>        <NA>  0.0852 0.292\n```\n:::\n:::\n\n:::\n:::\n\n## Efficiency\n\nThe *efficiency of a resolvable design* can be calculated as its mean s.e.d. compared to the (mean[^1]) s.e.d. of the analogous RCBD, i.e. leaving out the incomplete block effects within the replicates. Above, we have already calculated the mean s.e.d. of our resolvable design so we can square it and get `avg_sed_mod_rb^2` which is 0.07292. Accordingly, we can fit a model leaving out the incomplete block effects and get the s.e.d. just like before and also square it:\n\n[^1]: In this scenario, all s.e.d. of the RCBD model would be identical so we don't really need to get the average, but could instead argue that there is only one constant s.e.d.\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_sed_mod_RCBD <- lm(yield ~ gen + rep, data = dat) %>% \n  emmeans(pairwise ~ \"gen\",\n          adjust = \"none\",\n          lmer.df = \"kenward-roger\") %>%\n  pluck(\"contrasts\") %>% # extract diffs\n  as_tibble() %>% # format to table\n  pull(\"SE\") %>% # extract s.e.d. column\n  mean()\n\navg_sed_mod_RCBD^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0.08972397\n```\n:::\n:::\n\n\nFinally, the efficiency of this resolvable design is then\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_sed_mod_RCBD^2 / avg_sed_mod_rb^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1.230428\n```\n:::\n:::\n\n\nmeaning that the resolvable design is indeed more efficient since the efficiency is > 1.\n",
    "supporting": [
      "alpha_johnwilliams1995_files\\figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}