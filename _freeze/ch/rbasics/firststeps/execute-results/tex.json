{
  "hash": "8520e15d0d0adcc88c21f303d498673e",
  "result": {
    "markdown": "---\ntitle: \"First steps in R\"\nabstract: \"Data types, vectors, functions and R packages.\"\n---\n\n\n\n\n\nThis chapter is mostly aimed at people who are very new to R. However, people who do know R may still find useful insights from the sections where I emphasize how I use R.\n\n::: callout-note\nThis is certainly not the best tutorial you'll ever find, so if you want other tutorials check out this curated list of R Tutorials [here](https://github.com/ujjwalkarn/DataScienceR).\n:::\n\nFurthermore, this tutorial teaches R the way I use it, which means you can do (and may have done) almost everything I do here with other code/functions/approaches. \"The way I use it\" mostly refers to me using the [{tidyverse}](https://www.tidyverse.org/), which *\"is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures\"* and has become quite popular over the last years. [Here](https://dplyr.tidyverse.org/articles/base.html) is a direct comparison of how to do things in R with *base R* and via the tidyverse.\n\n# Let's go\n\nYou can use R like a calculator. It does not matter[^1] whether you put spaces in or not as shown here:\n\n[^1]: As long as you are dealing with numbers and calculations. Spaces do matter when we are talking about s*trings* (i.e. text).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2+3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n2 *   6\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 12\n```\n:::\n:::\n\n\n\nSimilar to what you may know from Excel, you can use functions like e.g. `sqrt()` to obtain the square root of a number:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3\n```\n:::\n:::\n\n\n\nYou can find out more about a function by running the command with a question mark in front: `?sqrt()`.\n\nBesides built-in functions, R also knows certain things like $\\pi$ or the alphabet, which are stored in the [built-in constants](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Constants.html) named `pi` and `letters`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npi\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3.141593\n```\n:::\n\n```{.r .cell-code}\nletters\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n```\n:::\n:::\n\n\n\nImportantly, you may also define your own variables via `=` or `<-`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nx = 20\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 20\n```\n:::\n\n```{.r .cell-code}\na_long_variable_name <- 2 + 4\na_long_variable_name\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 6\n```\n:::\n\n```{.r .cell-code}\nx + a_long_variable_name\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 26\n```\n:::\n\n```{.r .cell-code}\nmytext <- \"This is my text\"\nmytext\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"This is my text\"\n```\n:::\n:::\n\n\n\nNote that the variable `x` was overwritten - at first it was 3, but then it was 20. Also, as can be seen when the variable `a_long_variable_name` is defined, you may put more than just a simple number on the right side of the `<-` or `=`.\n\n# data types\n\nAs you just saw, R can deal with both numbers and text. We can check the data type via the `typeof()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(mytext)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"character\"\n```\n:::\n:::\n\n\n\nHere is a simplified overview over some of R's data types you may see more often:\n\n-   Numbers\n    -   `integer`/`int`: whole number\\\n        e.g. *42*, *-1504*\n    -   `numeric`/`num` & `double`/`dbl`: real number\\\n        e.g. *3.14*, *0.051795*\n-   Text\n    -   `character`/`chr`: string values\\\n        e.g. *\"hello\"*, *\"Two words\"*\n-   Factor\n    -   `factor`/`fct`: categorical variable that stores both string and integer data values as \"levels\"\\\n        e.g. *Control*, *Treatment*\n-   TRUE/FALSE\n    -   `logical`/`logi`: logical value\\\n        either *TRUE* or *FALSE*\n\n# vectors\n\nInstead of dealing with single numbers, we obviously want to deal with entire datasets. Before we get to an entire table with multiple rows and columns, the first step is to understand what a *vector* is in R: It is *a sequence of elements that share the same data type*. I often think about them as a single column in my dataset. Above, we actually already looked at a vector: `letters` is a built-in vector with 26 elements of the data type `character`. We could check this via the `length()` or `str()` functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 26\n```\n:::\n\n```{.r .cell-code}\nstr(letters)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n chr [1:26] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" ...\n```\n:::\n:::\n\n\n\nNote how the built-in constant `pi` is not a vector, because it's just a single number (*a.k.a.* a scalar).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n num 3.14\n```\n:::\n\n```{.r .cell-code}\nlength(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1\n```\n:::\n:::\n\n\n\nIf you want to create your own vector from scratch, you must put all the elements together in the `c()` function and separate them with commas:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmynumbers <- c(1, 4, 9, 12, 12, 12, 16)\nmynumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1]  1  4  9 12 12 12 16\n```\n:::\n\n```{.r .cell-code}\nmywords <- c(\"Hakuna\", \"Matata\", \"Simba\")\nmywords\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Hakuna\" \"Matata\" \"Simba\" \n```\n:::\n:::\n\n\n\nInterestingly, we can still apply the `sqrt()` function we used above to a vector with numbers and it will simply take the square-root of every element:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(mynumbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1.000000 2.000000 3.000000 3.464102 3.464102 3.464102 4.000000\n```\n:::\n:::\n\n\n\nHowever, there are also functions like `mean()` which return the mean of all numbers in a vector as a single output element:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(mynumbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 9.428571\n```\n:::\n:::\n\n\n\nc Comparison Operators\n\nIn R, comparison operators are used to compare values and variables, much like you might in mathematics or in spreadsheet formulas. They are fundamental in making decisions and controlling the flow of your code. Here are the most commonly used comparison operators:\n\nEqual to (`==`): Checks if the values on either side are equal.\nNot equal to (`!=`): Determines if two values are different.\nLess than (`<`): Verifies if the value on the left is smaller than the one on the right.\nGreater than (`>`): Checks if the value on the left is larger than the one on the right.\nLess than or equal to (`<=`): True if the left value is less than or equal to the right value.\nGreater than or equal to (`>=`): True if the left value is greater than or equal to the right value.\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 == 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n3 < 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n5 <= 5 \n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 != 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n2 > 6\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n5 >= 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n:::\n\n\n:::\n:::\n\n# function arguments\n\nSo far, the functions we used had in common that they required only one input. The really good stuff in R happens with more complex functions which need multiple inputs. Let us use `seq()` as an example, which seems simple enough, because it generates a sequence of numbers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\n\nAs you can see, putting in `1` and `10` separated by a comma generates a numeric vector with numbers from 1 to 10. However, I would like you to fully understand what is going on here, because it will help a lot with more complex functions.\n\nSee, we could switch the numbers and the function will work as expected:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(10, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 10  9  8  7  6  5  4  3  2  1\n```\n:::\n:::\n\n\n\nSo this means that the first input is always the starting point and the second one is always the end point of the sequence, right? Well, yes by default, but you can have it your way if you specifically use the names of the arguments.\n\nLooking at `?seq()` it says `seq(from = 1, to = 1, by = ...)` so this `seq(10, 1)` is more explicitly this: `seq(from = 1, to = 10, by = 1)`. Here is proof:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1, to = 10, by = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\n\nAgain, if you do not write out the arguments like this, it will simply assume the default order: The first number supplied is `from =` the second is `to =` and the third is `by =`. However, if we write out the arguments, we can use any order we like:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 9, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1 3 5 7 9\n```\n:::\n\n```{.r .cell-code}\nseq(from = 1, to = 9, by = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1 3 5 7 9\n```\n:::\n\n```{.r .cell-code}\nseq(from = 1, by = 2, to = 9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1 3 5 7 9\n```\n:::\n\n```{.r .cell-code}\nseq(1, 2, 9)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1\n```\n:::\n:::\n\n\n\nIn short: If you understand why the first three lines of the code above produce the same result, but the last one does not, you are good to go!\n\n# R packages\n\nAny function is always part of an R package.\n\n## base R\n\nAfter installing R there are many functions etc. you can use right away - which is what we did above. For example, when running `?mean`, the help page will tell you that this function is part of the [{base}](https://stat.ethz.ch/R-manual/R-devel/library/base/html/00Index.html) package. As the name suggests, this package is built-in and its functions are ready to use the moment you have installed R. You can verify this by going to the \"Packages\" tab in RStudio - you will find the *base* package and it will have a checked box next to it.\n\n## loading packages\n\nWhen looking at the \"Packages\" tab in RStudio you may notice that some packages are listed, but do not have a check mark in the box next to them. These are packages that are installed, but not loaded. When a package is not loaded, its functions cannot be used. In order to load a package, the default command is `library(package_name)`. This command must be run once every time you open a new R session.\n\n## installing additional packages\n\nR really shines because of the ability to install additional packages from external sources. Basically, anyone can create a function, put it in a package and make it available online. Some packages are very sophisticated and popular - *e.g.* the package `{ggplot2}`, which is not built-in, has been downloaded [75 million](https://cranlogs.r-pkg.org/badges/grand-total/ggplot2) times. In order to install a package, the default command is `install.packages(package_name)`. Alternatively, you can also click on the \"Install\" button in the top left of the \"Packages\" tab and type in the *package_name* there.\n\n::: callout-note\nA package only needs to be installed once, but\\\nA package must be loaded every time you open a new R session!\n:::\n\n[Here](https://github.com/qinwf/awesome-R) is a curated list of R packages and tools for different areas.\n",
    "supporting": [
      "firststeps_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}