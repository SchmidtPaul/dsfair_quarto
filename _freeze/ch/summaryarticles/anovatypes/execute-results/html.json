{
  "hash": "2e299c20035c82ba46a93d6b16b93933",
  "result": {
    "markdown": "---\ntitle: \"ANOVA Types\"\nabstract: \"What are ANOVA type I, II and III and why you should care\"\n---\n\n::: {.cell}\n\n:::\n\n\nIn the realm of statistical analysis, particularly when dealing with linear models, understanding the nuances between different types of ANOVA (Analysis of Variance) is crucial. Specifically, we will delve into the distinctions between Type I, Type II, and Type III ANOVA, their theoretical underpinnings, and practical implications, especially in the context of unbalanced data.\n\n# Background & Implementation\n\n * **Type I** ANOVA (Sequential): \n   * `stats::anova(model)`\n   * This method evaluates the significance of each predictor sequentially. For example, in a model with two predictors A and B, Type I ANOVA first assesses the effect of A, then the effect of B given A. The order of variables in your model is critical here, as it can alter the results, particularly in unbalanced datasets.\n\n * **Type II** ANOVA (Hierarchical): \n   * `car::Anova(model, type = \"II\")`\n   * Type II looks at each main effect in the model, but unlike Type I, it does not depend on the order of terms. It's particularly useful for models with main effects only, both in balanced and unbalanced datasets. Here, each main effect is tested after accounting for other main effects, but without considering interactions.\n\n * **Type III** ANOVA (Marginal): \n   * `car::Anova(model, type = \"III\")`\n   * This type tests each main effect after considering all other terms, including interactions. Type III is the go-to method when your model includes interactions, particularly in unbalanced datasets. It's robust against the order of terms in your model.\n \n# When Results Differ\n\nResults from these ANOVA types differ notably in unbalanced datasets. In balanced datasets, all three types usually yield similar results. However, in unbalanced scenarios:\n\n * Type I results depend on the order of terms. Type II and III remain consistent regardless of term order but differ from Type I.\n * Type III adjusts main effects for interactions, leading to different outcomes than Type II in models with interaction terms.\n \n# Examples\n\n## Unbalanced data & order of terms\n\nThis example is based on the augmented design chapter. The data is unbalanced so that for a `Type I` ANOVA there is a difference between the following two models, while for `Type II` and `Type III` it does not make a difference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod1 <- lm(yield ~ gen + block, data = dat)\nmod2 <- lm(yield ~ block + gen, data = dat)\n```\n:::\n\n\nHere are the p-values summarized in a single table:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(car)\n\ndat <- data.frame(\n  gen = c(\n    \"st\", \"14\", \"26\", \"ci\", \"17\", \"wa\", \"22\", \"13\", \"st\", \"ci\", \"04\", \"15\", \"30\",\n    \"03\", \"wa\", \"24\", \"st\", \"18\", \"27\", \"ci\", \"25\", \"28\", \"05\", \"wa\", \"st\", \"09\",\n    \"06\", \"ci\", \"wa\", \"20\", \"11\", \"23\", \"st\", \"02\", \"21\", \"wa\", \"ci\", \"10\", \"08\",\n    \"16\", \"st\", \"29\", \"07\", \"ci\", \"01\", \"wa\", \"12\", \"19\"\n  ),\n  yield = c(\n    2972L, 2405L, 2855L, 2592L, 2572L, 2608L, 2705L, 2391L, 3122L,\n    3023L, 3018L, 2477L, 2955L, 3055L, 2477L, 2783L, 2260L, 2603L,\n    2857L, 2918L, 2825L, 1903L, 2065L, 3107L, 3348L, 2268L, 2148L,\n    2940L, 2850L, 2670L, 3380L, 2770L, 1315L, 1055L, 1688L, 1625L, \n    1398L, 1293L, 1253L, 1495L, 3538L, 2915L, 3265L, 3483L, 3013L,\n    3400L, 2385L, 3643L),\n  block = rep(c(\"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\"), each = 8L),\n  row = c(\n    1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 1L, 2L, 3L, 4L, 5L, 6L, 7L,\n    8L, 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L,\n    15L, 16L, 9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L, 9L, 10L, 11L,\n    12L, 13L, 14L, 15L, 16L),\n  col = rep(rep(1:3, 2), each = 8L)\n)\n\n# Define models\nmod1 <- lm(yield ~ gen + block, data = dat)\nmod2 <- lm(yield ~ block + gen, data = dat)\n\n# Your get_p_values function\nget_p_values <- function(mymodel, myterm, mytype) {\n  if (mytype == \"I\") {\n    x <- broom::tidy(stats::anova(mymodel))\n  } else {\n    x <- broom::tidy(car::Anova(mymodel, type = mytype))\n  }\n  x %>% filter(term == myterm) %>% pull(p.value)\n}\n\n# Define terms and types\nterms <- c(\"gen\", \"block\")\ntypes <- c(\"I\", \"II\", \"III\")\nmodels <- list(mod1 = mod1, mod2 = mod2)\n\n# Creating the combined tibble\ncrossing(model = names(models), term = terms, type = types) %>%\n  rowwise() %>%\n  mutate(\n    p = get_p_values(models[[model]], term, type)\n  ) %>%\n  ungroup() %>% \n  pivot_wider(\n    names_from = term,\n    values_from = p\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 Ã— 4\n  model type       block     gen\n  <chr> <chr>      <dbl>   <dbl>\n1 mod1  I     0.000208   0.00911\n2 mod1  II    0.000208   0.293  \n3 mod1  III   0.000208   0.293  \n4 mod2  I     0.00000576 0.293  \n5 mod2  II    0.000208   0.293  \n6 mod2  III   0.000208   0.293  \n```\n:::\n:::\n\n\n## Interaction\n\nTODO\n\n# Conclusion\n\nIn most cases it's probably best to conduct a `Type III` ANOVA, e.g. via `car::Anova(model, type = \"III\")`.\n",
    "supporting": [
      "anovatypes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}