{
  "hash": "8d82e9f60d7de81659e5932f991b89f4",
  "result": {
    "markdown": "---\ntitle: \"One-way latin square design\"\nabstract: \"One-way ANOVA & pairwise comparison post hoc tests in a latin square design.\"\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# (install &) load packages\npacman::p_load(\n  agridat,\n  conflicted,\n  desplot,\n  emmeans,\n  ggtext,\n  multcomp,\n  multcompView,\n  tidyverse)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nPaket 'agridat' erfolgreich ausgepackt und MD5 Summen abgeglichen\n\nDie heruntergeladenen Bin√§rpakete sind in \n\tC:\\Users\\schmi\\AppData\\Local\\Temp\\RtmpuGwFTf\\downloaded_packages\n```\n:::\n\n```{.r .cell-code}\n# handle function conflicts\nconflict_prefer(\"filter\", \"dplyr\") \nconflict_prefer(\"select\", \"dplyr\")\n```\n:::\n\n\n\n# Data\n\nThis example data is taken from [{agridat}](https://kwstat.github.io/agridat/). It considers data published in @bridges1989 from a cucumber yield trial with four genotypes set up as a Latin square design. Notice that the original dataset considers two trials (at two locations), but we will focus on only a single trial here.\n\n## Import\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- agridat::bridges.cucumber %>% \n  as_tibble() %>% \n  filter(loc == \"Clemson\") %>% # filter data from only one location\n  select(-loc) # remove loc column which is now unnecessary\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 16 x 4\n   gen        row   col yield\n   <fct>    <int> <int> <dbl>\n 1 Dasher       1     3  44.2\n 2 Dasher       2     4  54.1\n 3 Dasher       3     2  47.2\n 4 Dasher       4     1  36.7\n 5 Guardian     1     4  33  \n 6 Guardian     2     2  13.6\n 7 Guardian     3     1  44.1\n 8 Guardian     4     3  35.8\n 9 Poinsett     1     1  11.5\n10 Poinsett     2     3  22.4\n11 Poinsett     3     4  30.3\n12 Poinsett     4     2  21.5\n13 Sprint       1     2  15.1\n14 Sprint       2     1  20.3\n15 Sprint       3     3  41.3\n16 Sprint       4     4  27.1\n```\n:::\n:::\n\n\n\n## Format\n\nFor our analysis, `gen`, `row` and `col` should be encoded as factors. However, the `desplot()` function needs `row` and `col` as formatted as integers. Therefore we create copies of these columns encoded as factors and named `rowF` and `colF`. Below are two ways how to achieve this:\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- dat %>%\n  mutate(\n    colF = as.factor(col),\n    rowF = as.factor(row)\n  )\n```\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat <- dat %>%\n  mutate(across(\n    .cols = c(row, col), \n    .fns = ~ as.factor(.x), \n    .names = (\"{.col}F\")\n  ))\n```\n:::\n\n\n:::\n:::\n\n## Explore\n\nWe make use of [`dlookr::describe()`](../../summaryarticles/usefulthings.qmd#dlookr) to conveniently obtain descriptive summary tables. Here, we get can summarize per genotype, per row and per column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  group_by(gen) %>% \n  dlookr::describe(yield) %>% \n  select(2:sd) %>%\n  arrange(desc(mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 4 x 5\n  gen          n    na  mean    sd\n  <fct>    <int> <int> <dbl> <dbl>\n1 Dasher       4     0  45.6  7.21\n2 Guardian     4     0  31.6 12.9 \n3 Sprint       4     0  26.0 11.4 \n4 Poinsett     4     0  21.4  7.71\n```\n:::\n:::\n\n\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  group_by(rowF) %>% \n  dlookr::describe(yield) %>% \n  select(2:sd) %>%\n  arrange(desc(mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 4 x 5\n  rowF      n    na  mean    sd\n  <fct> <int> <int> <dbl> <dbl>\n1 3         4     0  40.7  7.36\n2 4         4     0  30.3  7.28\n3 2         4     0  27.6 18.1 \n4 1         4     0  26.0 15.4 \n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  group_by(colF) %>% \n  dlookr::describe(yield) %>% \n  select(2:sd) %>%\n  arrange(desc(mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 4 x 5\n  colF      n    na  mean    sd\n  <fct> <int> <int> <dbl> <dbl>\n1 4         4     0  36.1 12.2 \n2 3         4     0  35.9  9.67\n3 1         4     0  28.2 14.9 \n4 2         4     0  24.4 15.6 \n```\n:::\n:::\n\n\n:::\n:::\n\nAdditionally, we can decide to plot our data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(data = dat) +\n  aes(y = yield, x = gen, color = colF, shape = rowF) +\n  geom_point() +\n    scale_x_discrete(\n    name = \"Genotype\"\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  scale_color_discrete(\n    name = \"Column\"\n  ) +\n  scale_shape_discrete(\n    name = \"Row\"\n  ) +\n  theme_classic()\n```\n\n::: {.cell-output-display}\n![](latsq_bridges1989_files/figure-pdf/unnamed-chunk-9-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\nFinally, since this is an experiment that was laid with a certain experimental design (= a Latin square design) - it makes sense to also get a field plan. This can be done via `desplot()` from [{desplot}](../../summaryarticles/usefulthings.qmd#desplot). We can even create a second field plan that gives us a feeling for the yields per plot.\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndesplot(\n  data = dat,\n  flip = TRUE, # row 1 on top, not on bottom\n  form = gen ~ col + row, # fill color per genotype       \n  out1 = rowF, # line between rows\n  out2 = colF, # line between columns\n  out1.gpar = list(col = \"black\", lwd = 2), # out1 line style\n  out2.gpar = list(col = \"black\", lwd = 2), # out2 line style\n  text = gen, # gen names per plot\n  cex = 1, # gen names: font size\n  shorten = FALSE, # gen names: don't abbreviate\n  main = \"Field layout\", # plot title\n  show.key = FALSE # hide legend\n  ) \n```\n\n::: {.cell-output-display}\n![](latsq_bridges1989_files/figure-pdf/unnamed-chunk-10-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\ndesplot(\n  data = dat,\n  flip = TRUE, # row 1 on top, not on bottom\n  form = yield ~ col + row, # fill color according to yield     \n  out1 = rowF, # line between rows\n  out2 = colF, # line between columns\n  out1.gpar = list(col = \"black\", lwd = 2), # out1 line style\n  out2.gpar = list(col = \"black\", lwd = 2), # out2 line style\n  text = gen, # gen names per plot\n  cex = 1, # gen names: font size\n  shorten = FALSE, # gen names: don't abbreviate\n  main = \"Yield per plot\", # plot title\n  show.key = FALSE # hide legend\n  ) \n```\n\n::: {.cell-output-display}\n![](latsq_bridges1989_files/figure-pdf/unnamed-chunk-11-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n:::\n:::\n\nThus, `Dasher` seems to be the most promising genotype in terms of yield. Moreover, it can be seen that yields were generally higher in column 4 and row 3.\n\n# Model\n\nFinally, we can decide to fit a linear model with `yield` as the response variable and (fixed) `gen`, `rowF` and `colF` effects.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod <- lm(yield ~ gen + rowF + colF, data = dat)\n```\n:::\n\n\n\n::: callout-important\nIt is crucial to add `rowF`/`colF` and not `row`/`col` to the model here, since only the former are formatted as factors. They should be formatted as factors, so that the model estimates one effect for each of their levels. The model would estimate a single slope for `row` and `col`, respectively, which is nonsensical: It would suggest that row 4 is twice as much as row 2 etc.\n:::\n\n::: custom-callout-modass\nIt would be at this moment (i.e. after fitting the model and before running the ANOVA), that you should check whether the model assumptions are met. Find out more in the [summary article \"Model Diagnostics\"](../../summaryarticles/modeldiagnostics.qmd)\n:::\n\n# ANOVA\n\nBased on our model, we can then conduct an ANOVA:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nANOVA <- anova(mod)\nANOVA\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nAnalysis of Variance Table\n\nResponse: yield\n          Df  Sum Sq Mean Sq F value  Pr(>F)  \ngen        3 1316.80  438.93  9.3683 0.01110 *\nrowF       3  528.35  176.12  3.7589 0.07872 .\ncolF       3  411.16  137.05  2.9252 0.12197  \nResiduals  6  281.12   46.85                  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n:::\n:::\n\n\n\nAccordingly, the ANOVA's F-test found the genotype effects to be statistically different (p = 0.011*).\n\n# Mean comparison\n\nBesides an ANOVA, one may also want to compare adjusted yield means between genotypes via post hoc tests (t-test, Tukey test etc.).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_comp <- mod %>% \n  emmeans(specs = ~ gen) %>% # adj. mean per genotype\n  cld(Letters = letters) # compact letter display (CLD)\n\nmean_comp\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n gen      emmean   SE df lower.CL upper.CL .group\n Poinsett   21.4 3.42  6     13.1     29.8  a    \n Sprint     25.9 3.42  6     17.6     34.3  a    \n Guardian   31.6 3.42  6     23.3     40.0  ab   \n Dasher     45.5 3.42  6     37.2     53.9   b   \n\nResults are averaged over the levels of: rowF, colF \nConfidence level used: 0.95 \nP value adjustment: tukey method for comparing a family of 4 estimates \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping symbol,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n```\n:::\n:::\n\n\n\nNote that if you would like to see the underlying individual contrasts/differences between adjusted means, simply add `details = TRUE` to the `cld()` statement. Furthermore, check out the [Summary Article \"Compact Letter Display\"](../../summaryarticles/compactletterdisplay.qmd).\n\nFinally, we can create a plot that displays both the raw data and the results, *i.e.* the comparisons of the adjusted means that are based on the linear model.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nmy_caption <- \"Black dots represent raw data. Red dots and error bars represent adjusted means with 95% confidence limits per genotype Means followed by a common letter are not significantly different according to the Tukey-test.\"\n\nggplot() +\n  aes(x = gen) +\n  # black dots representing the raw data\n  geom_point(\n    data = dat,\n    aes(y = yield)\n  ) +\n  # red dots representing the adjusted means\n  geom_point(\n    data = mean_comp,\n    aes(y = emmean),\n    color = \"red\",\n    position = position_nudge(x = 0.1)\n  ) +\n  # red error bars representing the confidence limits of the adjusted means\n  geom_errorbar(\n    data = mean_comp,\n    aes(ymin = lower.CL, ymax = upper.CL),\n    color = \"red\",\n    width = 0.1,\n    position = position_nudge(x = 0.1)\n  ) +\n  # red letters \n  geom_text(\n    data = mean_comp,\n    aes(y = emmean, label = str_trim(.group)),\n    color = \"red\",\n    position = position_nudge(x = 0.2),\n    hjust = 0\n  ) +\n  scale_x_discrete(\n    name = \"Genotype\"\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  scale_color_discrete(\n    name = \"Block\"\n  ) +\n  theme_classic() +\n  labs(caption = my_caption) +\n  theme(plot.caption = element_textbox_simple(margin = margin(t = 5)),\n        plot.caption.position = \"plot\")\n```\n\n::: {.cell-output-display}\n![](latsq_bridges1989_files/figure-pdf/unnamed-chunk-15-1.pdf){fig-pos='H'}\n:::\n:::\n",
    "supporting": [
      "latsq_bridges1989_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "\\usepackage{booktabs}\r\n\\usepackage{longtable}\r\n\\usepackage{array}\r\n\\usepackage{multirow}\r\n\\usepackage{wrapfig}\r\n\\usepackage{float}\r\n\\usepackage{colortbl}\r\n\\usepackage{pdflscape}\r\n\\usepackage{tabu}\r\n\\usepackage{threeparttable}\r\n\\usepackage{threeparttablex}\r\n\\usepackage[normalem]{ulem}\r\n\\usepackage{makecell}\r\n\\usepackage{xcolor}\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}