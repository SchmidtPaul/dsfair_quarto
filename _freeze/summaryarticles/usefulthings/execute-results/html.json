{
  "hash": "8283ed328f34ce10be20b8ced72339f7",
  "result": {
    "markdown": "---\ntitle: \"Useful things\"\nabstract: \"A personal collection of useful R packages and more.\"\n---\n\n\n\n\nThis chapter is a collection of things I wish I had known earlier in my years using R and that I hope can be of use to you. Sections are named after R packages or whatever applies and sorted alphabetically.\n\n# `{broom}`\n\nIn R, results from statistical tests, models etc. are often formatted in a way that may not be optimal for further processing steps. Luckily, [{broom}](https://broom.tidymodels.org/) will format the results of [the most common functions](https://broom.tidymodels.org/articles/available-methods.html) into [tidy data structures](https://www.jstatsoft.org/article/view/v059i10).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Correlation Analysis for built-in example data \"mtcars\"\nmycor <- cor.test(mtcars$mpg, mtcars$disp)\nmycor\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\n\tPearson's product-moment correlation\n\ndata:  mtcars$mpg and mtcars$disp\nt = -8.7472, df = 30, p-value = 9.38e-10\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n -0.9233594 -0.7081376\nsample estimates:\n       cor \n-0.8475514 \n```\n:::\n\n```{.r .cell-code}\nlibrary(broom)\ntidy(mycor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 1 × 8\n  estimate statistic  p.value parameter conf.low conf.high method        alter…¹\n     <dbl>     <dbl>    <dbl>     <int>    <dbl>     <dbl> <chr>         <chr>  \n1   -0.848     -8.75 9.38e-10        30   -0.923    -0.708 Pearson's pr… two.si…\n# … with abbreviated variable name ¹​alternative\n```\n:::\n:::\n\n\n# `{conflicted}`\n\nSometimes, different packages have different functions with identical names. A famous example is the function `filter()`, which exists in [{stats}](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/filter) and [{dplyr}](https://dplyr.tidyverse.org/reference/filter.html). If both of these packages are loaded, it is not clear which of the two functions should be used. This is called a function conflict and it is especially tricky here since {stats} is always loaded. By default, R will simply pick the package that was loaded later - which is obviously not optimal.\n\nOne way of dealing with function conflicts is by using the [packagename::functionname()](https://stackoverflow.com/questions/35240971/what-are-the-double-colons-in-r) method, because when writing `dplyr::filter()` instead of `filter()` it is no longer ambiguous which function you are referring to.\n\nAnother way of dealing with function conflicts more explicitly is by loading the {conflicted} package. Once it is loaded, function conflicts will lead to an `Error` that forces you to deal with the issue:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(conflicted)\nlibrary(dplyr)\n\nPlantGrowth %>% filter(weight > 6)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError:\n! [conflicted] `filter` found in 2 packages.\nEither pick the one you want with `::` \n* dplyr::filter\n* stats::filter\nOr declare a preference with `conflict_prefer()`\n* conflict_prefer(\"filter\", \"dplyr\")\n* conflict_prefer(\"filter\", \"stats\")\n```\n:::\n:::\n\n\nAs you can see, it first suggests using the [packagename::functionname()](https://stackoverflow.com/questions/35240971/what-are-the-double-colons-in-r) method mentioned above, but also points to the `conflict_prefer()` function. By running this function once in the beginning of the script, R will always use the function from the package that you declared the \"winner\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(conflicted)\nlibrary(dplyr)\n\nconflict_prefer(\"filter\", \"dplyr\")\n\nPlantGrowth %>% filter(weight > 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  weight group\n1   6.11  ctrl\n2   6.03  trt1\n3   6.31  trt2\n4   6.15  trt2\n```\n:::\n:::\n\n\n\n# `{desplot}`\n\n[{desplot}](https://kwstat.github.io/desplot/) makes it easy to plot experimental designs of field trials in agriculture. However, you do need two columns that provide the x and y coordinates of the individual plots on your field.\n\nTO DO\n\n# `{dlookr}`\n\nWhen providing descriptive statistics tables, one may find the number of relevant measures become annoyingly large so that even with the {tidyverse}, several lines of code are necessary. Here are just five measures, and they are not even including the [`na.rm = TRUE`](https://www.statology.org/na-rm/) argument, which is necessary for data with missing values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nPlantGrowth %>% \n  group_by(group) %>% \n  summarise(\n    mean = mean(weight),\n    stddev = sd(weight),\n    median = median(weight),\n    min = min(weight),\n    max = max(weight)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 3 × 6\n  group  mean stddev median   min   max\n  <fct> <dbl>  <dbl>  <dbl> <dbl> <dbl>\n1 ctrl   5.03  0.583   5.15  4.17  6.11\n2 trt1   4.66  0.794   4.55  3.59  6.03\n3 trt2   5.53  0.443   5.44  4.92  6.31\n```\n:::\n:::\n\n\nObviously, there are multiple packages who try to address just that. The one I've been using for some time now is [{dlookr}](https://choonghyunryu.github.io/dlookr/) with its `describe()` function. It actually provides more measures than I usually need[^1], but it has everything I want and I disregard the rest (via `select()`).\n\n[^1]: Keep in mind that `p00` is the 0th percentile and thus the minimum. Analogously, `p50` is the median and `p100` the maximum.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPlantGrowth %>%\n  group_by(group) %>%\n  dlookr::describe(weight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 3 × 27\n  described_…¹ group     n    na  mean    sd se_mean   IQR skewn…² kurto…³   p00\n  <chr>        <fct> <int> <int> <dbl> <dbl>   <dbl> <dbl>   <dbl>   <dbl> <dbl>\n1 weight       ctrl     10     0  5.03 0.583   0.184 0.743   0.321  -0.229  4.17\n2 weight       trt1     10     0  4.66 0.794   0.251 0.662   0.659  -0.203  3.59\n3 weight       trt2     10     0  5.53 0.443   0.140 0.467   0.673  -0.324  4.92\n# … with 16 more variables: p01 <dbl>, p05 <dbl>, p10 <dbl>, p20 <dbl>,\n#   p25 <dbl>, p30 <dbl>, p40 <dbl>, p50 <dbl>, p60 <dbl>, p70 <dbl>,\n#   p75 <dbl>, p80 <dbl>, p90 <dbl>, p95 <dbl>, p99 <dbl>, p100 <dbl>, and\n#   abbreviated variable names ¹​described_variables, ²​skewness, ³​kurtosis\n```\n:::\n:::\n\n\n::: callout-note\nIt is intentional that I did not actually load the {dlookr} package, but instead used its `describe()` function via the [packagename::functionname()](https://stackoverflow.com/questions/35240971/what-are-the-double-colons-in-r) method. This is because of a minor bug in the {dlookr} package described [here](https://github.com/choonghyunryu/dlookr/issues/79), which is only relevant if you are using the package with knitr/Rmarkdown/quarto. I am using quarto to generate this website and thus I avoid loading the package. This is fine for me, since I usually only need this one function one time during an analysis. It is also fine for you, since the code works the same way in a standard R script.\n:::\n\n# `{ggtext}`\n\nAdding long text to plots created via {ggplot2} is problematic, since you have to insert line breaks yourself. However, [{ggext}](https://wilkelab.org/ggtext/)'s `geom_textbox()` for data labels and `element_textbox_simple()` for title, caption etc. will automatically add line breaks:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongtext <- \"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum.\"\n```\n:::\n\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot() +\n  \n  \n  aes(y = 1, x = 1, label = longtext) +\n  geom_label() +\n  labs(caption = longtext)\n```\n\n::: {.cell-output-display}\n![](usefulthings_files/figure-html/unnamed-chunk-8-1.png){width=1500}\n:::\n:::\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggtext)\n\nggplot() +\n  theme(plot.caption =\n          element_textbox_simple()) +\n  aes(y = 1, x = 1, label = longtext) +\n  geom_textbox() +\n  labs(caption = longtext)\n```\n\n::: {.cell-output-display}\n![](usefulthings_files/figure-html/unnamed-chunk-9-1.png){width=1500}\n:::\n:::\n\n:::\n:::\n\n# `{here}`\n\nTO DO\n\n# `{insight}`\n\n[TO DO](https://easystats.github.io/insight/reference/format_p.html)\n\n# `{janitor}`\n\nTO DO\n\n# Keyboard shortcuts\n\nHere are shortcuts I actually use regularly in RStudio:\n\n| Shortcut              | Description                                   |\n|-----------------------|-----------------------------------------------|\n| CTRL+ENTER            | Run selected lines of code                    |\n| CTRL+C                | Convert all selected lines to comment         |\n| CTRL+SHIFT+M          | Insert `%>%`                                  |\n| CTRL+SHIFT+R          | Insert code section header                    |\n| CTRL+LEFT/RIGHT       | Jump to Word                                  |\n| CTRL+SHIFT+LEFT/RIGHT | Select Word                                   |\n| ALT+LEFT/RIGHT        | Jump to Line Start/End                        |\n| ALT+SHIFT+LEFT/RIGHT  | Select to Line Start/End                      |\n| CTRL+A                | Highlight everything (to run the entire code) |\n| CTRL+Z                | Undo                                          |\n\nKeyboard shortcuts can be customized in RStudio as described [here](https://support.rstudio.com/hc/en-us/articles/206382178-Customizing-Keyboard-Shortcuts-in-the-RStudio-IDE).\n\n# `{modelbased}`\n\n[TO DO](https://easystats.github.io/modelbased/articles/estimate_response.html)\n\n# `{openxlsx}`\n\nTO DO\n\n# `{pacman}`\n\n[<img src=\"https://github.com/trinker/pacman/blob/master/inst/pacman_logo/r_pacman.png?raw=true\" width=\"100\"/>](https://tidyverse.tidyverse.org/)\n\nYou now know how to install and load R packages the standard way. However, over the years I switched to using the function `p_load()` from the {pacman} package instead of `library()` and `install.packages()`. The reason is simple: Usually R-scripts start with multiple lines of `library()` statements that load the necessary packages. However, when this code is run on a different computer, the user may not have all these packages installed and will therefore get an error message. This can be avoided by using the `p_load()`, because it\n\n-   loads all packages that are installed and\n-   installs and loads all packages that are not installed.\n\nObviously, {pacman} itself must first be installed (the standard way). Moreover, you may now think that in order to use `p_load()` we do need a single `library(pacman)` first. However, we can avoid this by writing `pacman::p_load()` instead. Simply put, writing `package_name::function_name()` [makes sure](https://stat.ethz.ch/R-manual/R-devel/library/base/html/ns-dblcolon.html) that this explicit function from this explicit package is being used. Additionally, R actually lets you use this function without loading the corresponding package. Thus, we now arrived at the way I handle packages at the beginning of all my R-scripts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(\n  package_name_1,\n  package_name_2,\n  package_name_3\n)\n```\n:::\n\n\n# `{patchwork}`\n\nTO DO\n\n# `{performance}`\n\nTO DO\n\n# `{readxl}`\n\nTO DO\n\n# `{reprex}`\n\nTO DO\n\n# `{scales}`\n\nTO DO\n\n# `%in%` and `%not_in%`\n\nR has the built-in function `%in%` which checks whether something is present in a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreatments <- c(\"Ctrl\", \"A\", \"B\")\n```\n:::\n\n\nNot only can we checke which treatments are present in our `treatment` vector (left), but we can also easily keep only those that are (right).\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"A\", \"D\") %in% treatments \n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1]  TRUE FALSE\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"A\", \"D\") %>% .[. %in% treatments]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"A\"\n```\n:::\n:::\n\n:::\n:::\n\nNot built-in, for some reason, is the opposite of that function - checking whether something is **not** present. Yet, we can quickly built our own function that does exactly that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`%not_in%` <- Negate(`%in%`)\n```\n:::\n\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"A\", \"D\") %not_in% treatments \n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE  TRUE\n```\n:::\n:::\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\"A\", \"D\") %>% .[. %not_in% treatments]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"D\"\n```\n:::\n:::\n\n:::\n:::\n\n# `system('open \"file.png\"')`\n\n[TO DO](https://gist.github.com/SchmidtPaul/5cd96b53449f5f50cbda725d4cdacf9b)\n",
    "supporting": [
      "usefulthings_files\\figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}