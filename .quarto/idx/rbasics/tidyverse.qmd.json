{"title":"The tidyverse","markdown":{"yaml":{"title":"The tidyverse","date":"2022-10-09","abstract":"Pipe (%>%), Tibbles, dplyr-verbs, long/wide format and more from the tidyverse."},"headingText":"| include: false","containsRefs":false,"markdown":"\n\n```{r}\nknitr::opts_chunk$set(\n  class.output = \"custom-output\"\n)\n```\n\nWhen using R, you will sooner or later hear about the [{tidyverse}](https://www.wikiwand.com/en/Tidyverse). The tidyverse is a collection of R packages that \"share an underlying design philosophy, grammar, and data structures\" of tidy data. The individual tidyverse packages comprise some of the most downloaded R packages.\n\nInstall the complete tidyverse with:\n\n```{r}\n#| eval: false\n\ninstall.packages(\"tidyverse\")\n# or\npacman::p_load(\"tidyverse\")\n```\n\n|                                                                 ggplot2                                                                  |                                                                dplyr                                                                 |                                                                 tibble                                                                 |                                                                 forcats                                                                  |                                                                 stringr                                                                  |\n|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|\n| [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/ggplot2.png\" width=\"100\"/>](https://ggplot2.tidyverse.org/) | [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/dplyr.png\" width=\"100\"/>](https://dplyr.tidyverse.org/) | [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/tibble.png\" width=\"100\"/>](https://tibble.tidyverse.org/) | [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/forcats.png\" width=\"100\"/>](https://forcats.tidyverse.org/) | [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/stringr.png\" width=\"100\"/>](https://stringr.tidyverse.org/) |\n\n: Some of my favorite tidyverse packages\n\nI did not use the tidyverse packages in my first years using R, but I wish I did. While you can often reach your goal with or without using the tidyverse packages, I personally prefer using them. Thus, they are used extensively throughout the chapters of this website.\n\nDuring the next sections I will try to explain how to use some of these packages and sometimes compare them to the Base R (= non-tidyverse) alternative.\n\n::: custom-callout-addref\n-   [\"R for Data Science\"](https://r4ds.had.co.nz/) [@Wickham_2017], which is a book that can be read online for free and was written by the package authors themselves.\n:::\n\n# Tables\n\nFinally, we can now talk about data tables with rows and columns. In R, I like to think of a table as multiple vectors side by side, so that each column is a vector.\n\n## data.frame\n\nBase R has a standard format for data tables called `data.frame`. Here is an example table that is an R built-in, just like `pi` is - it is called `PlantGrowth`:\n\n```{r}\nPlantGrowth\n```\n\nLet us create a copy of this table called `df` (**d**ata**f**rame) and then use some helpful functions to get a first impression of this data:\n\n```{r}\ndf <- PlantGrowth\nstr(df)\nsummary(df)\n```\n\nWe can see that this dataset has 30 observations (=rows) and 2 variables (=columns) and is of the type \"data.frame\". Furthermore, the first variable is called `weight` and contains numeric values for which we get some measures of central tendency like the minimum, maximum, mean and median. The second variable is called `group` and is of the type factor containing a total of three different levels, which each appear 10 times.\n\nIf you want to extract/use values of only one column of such a data.frame, you write the name of the data.frame, then a `$` and finally the name of the respective column. It returns the values of that column as a vector:\n\n```{r}\ndf$weight\ndf$group\n```\n\n## tibble\n\nOne major aspect of the tidyverse is formatting tables as **tibble instead of data.frame**. A tibble *\"is a modern reimagining of the data.frame, keeping what time has proven to be effective, and throwing out what is not.\"* It is super simple to convert a data.frame into a tibble, but you must have the tidyverse R package {tibble} installed and loaded - which it is if you are loading the entire {tidyverse}. Let us convert our `df` into a tibble and call it `tbl`:\n\n```{r}\npacman::p_load(tidyverse)\ntbl <- as_tibble(df)\ntbl\n```\n\nOf course, the data itself does not change - only its format and the way it is displayed to us in R. If you compare the output we get from printing `tbl` here to that of printing `df` above, I would like to point out some things I find extremely convenient for tibbles:\n\n1.  There is an extra first line telling us about the number of rows and columns.\n2.  There is an extra line below the column names telling us about the data type of each column.\n3.  Only the first ten rows of data are printed and a *\"... with 20 more rows\"* is added below.\n4.  It can't be seen here, but this would analogously happen if there were too many columns.\n5.  It can't be seen here, but missing values `NA` and negative numbers are printed in red.\n\nFinally, note that in its heart, a tibble is still a data.frame and in most cases you can do everything with a tibble that you can do with a data.frame:\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\n#| code-overflow: wrap\nclass(tbl)\nstr(tbl)\nsummary(tbl)\ntbl$weight\ntbl$group\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\n#| code-overflow: wrap\nclass(df)\nstr(df)\nsummary(df)\ndf$weight\ndf$group\n```\n:::\n:::\n\nTherefore, I almost always format my datasets as tibbles.\n\n# Plots\n\nBase R has a `plot()` function which is good at getting some first data visualizations with very little code. It guesses what type of plot you would like to see via the data type of the respective data to be plotted:\n\n```{r}\n#| layout-ncol: 3\n#| fig-width: 5\n#| fig-height: 4\n\nplot(df$weight) # scatter plot of values in the order they appear\nplot(df$group) # bar plot of frequency of each level\nplot(x = df$group, y = df$weight) # boxplot for values of each level\n```\n\nHowever, I really just use `plot()` to get a quick first glance at data. In order to get professional visualizations I always use the tidyverse package `{ggplot2}` and its function `ggplot()`. It seems like it can create any plot you can imagine and there are multiple examples with increasing complexity spread out through this website's chapters.\n\n::: custom-callout-addref\n-   Cédric Scherer's [-@CedricScherer_2022] [A ggplot2 tutorial for beautiful plotting in R](https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/)\n-   [ggplot2 extensions gallery](https://exts.ggplot2.tidyverse.org/gallery/)\n:::\n\n# The pipe operator\n\nThe pipe operator *\"completely changed the way how we code in R, making it more simple and readable\"* [@álvarez_2021]. I started using the pipe as `%>%` from the {dplyr} package[^1]. However, since May 18, 2021 (= R 4.1.0) the pipe is officially part of Base R - although written as `|>`[^2].\n\n[^1]: But it was not the first package to use it. [This blog post](http://adolfoalvarez.cl/blog/2021-09-16-plumbers-chains-and-famous-painters-the-history-of-the-pipe-operator-in-r/) has a nice summary of the history of the pipe operator in R.\n\n[^2]: Note that there are some differences between `%>%` and `|>` - find more about it *e.g.* [here](https://twitter.com/TimTeaFan/status/1582118234220007424), [here](http://adolfoalvarez.cl/blog/2021-09-16-plumbers-chains-and-famous-painters-the-history-of-the-pipe-operator-in-r/#base-r) or [here](https://stackoverflow.com/questions/67633022/what-are-the-differences-between-rs-new-native-pipe-and-the-magrittr-pipe).\n\nTo understand what makes it so great we need to start using more than one function at a time. So far, we have only used functions individually. Yet, in real life you will often find yourself having to combine multiple functions. As a fictional example, let's say that from the `PlantGrowth` data, we want to extract a sorted vector of the square root of all weight-values that belong to the `ctrl` group. I will show three approaches how to accomplish this\n\n## No pipe - intermediate steps\n\nUsing one function at a time and saving the output in the variables `a` - `d`, we can do this:\n\n```{r}\na <- filter(PlantGrowth, group == \"ctrl\")\nb <- pull(a, weight) # same as: b <- a$weight\nc <- sqrt(b)\nd <- round(c, digits = 1)\nsort(d)\n```\n\n## No pipe - nesting functions\n\nJust like in MS Excel, it is possible to write functions inside of functions so that we can do this:\n\n```{r}\nsort(round(sqrt(pull(filter(PlantGrowth, group == \"ctrl\"), weight)), digits = 1))\n```\n\n## Pipe!\n\nThis approach (i) allows you to write functions from left to right / top to bottom and thus in the order they are executed and the way you think about them and (ii) does not create extra variables for intermediate steps:\n\n```{r}\nPlantGrowth %>% \n  filter(group == \"ctrl\") %>% \n  pull(weight) %>% \n  sqrt() %>% \n  round(digits = 1) %>% \n  sort()\n```\n\nYou can think about it like this: Something (in this case the `PlantGrowth` data.frame) goes into the pipe and is directed to the next function `filter()`. By default, this function takes what came out of the previous pipe and puts it as its first argument. This happens with every pipe. You'll notice that all the functions who required two arguments above, now only need one argument, *i.e.* the additional argument, because the main argument stating which data is to be used is by default simply what came out of the previous pipe. Accordingly, the functions `sqrt()` and `sort()` appear empty here, because they only need one piece of information and that is which data they should work with. Finally note that you can easily highlight only some of the lines up until one of the pipes to see the intermediate results.\n\n::: callout-note\nThe keyboard shortcut for writing `%>%` in RStudio is **CTRL+SHIFT+M**. Keyboard shortcuts can be customized in RStudio as described [here](https://support.rstudio.com/hc/en-us/articles/206382178-Customizing-Keyboard-Shortcuts-in-the-RStudio-IDE).\n:::\n\n# dplyr verbs\n\nTaken directly from [the documentation](https://dplyr.tidyverse.org/):\n\n> {dplyr} is a grammar of data manipulation, providing a consistent set of verbs that help you solve the most common data manipulation challenges:\n>\n> -   `mutate()` adds new variables that are functions of existing variables.\n>\n> -   `select()` picks variables based on their names.\n>\n> -   `filter()` picks cases based on their values.\n>\n> -   `summarise()` reduces multiple values down to a single summary.\n>\n> -   `arrange()` changes the ordering of the rows.\n>\n> These all combine naturally with `group_by()` which allows you to perform any operation \"by group\". If you are new to dplyr, the best place to start is [the data transformation chapter](https://r4ds.had.co.nz/transform.html) in *R for data science* [@Wickham_2017].\n\nIn my experience you really can do most of the data manipulation before and after the actual statistics with these functions. In other words, it is exactly these functions who can and should replace the manual work you may currently even be doing in MS Excel. In the following sections I will give very brief examples of how to use these functions while always pointing to more thorough resources.\n\n## mutate()\n\nThis function is useful whenever you want to change existing columns or add new columns to your table. To keep the following examples short and simple, let's create `tbl2` as only the first six rows of `tbl` via the `head()` function:\n\n```{r}\ntbl2 <- head(tbl)\ntbl2\n```\n\nLet's start by adding 2 to the `weight` in our data. Below, we do this two different ways: by adding a column named `new` to the dataset (left) and by replacing/overwriting the original `weight` column (right):\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl2 %>% \n  mutate(new = weight + 2)\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl2 %>% \n  mutate(weight = weight + 2)\n```\n:::\n:::\n\nWe can also create multiple columns at once (left) and make the values of the new column dynamically depend on the other columns via `case_when()` (right):\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl2 %>%\n  mutate(\n    `Name with Space` = \"Hello!\",\n    number10 = 10\n  )\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl2 %>% \n  mutate(larger5 = case_when(\n    weight > 5 ~ \"yes\",\n    weight < 5 ~ \"no\"\n  ))\n```\n:::\n:::\n\nFinally, we can efficiently apply the same function to multiple columns at once via `across()`. We can select the columns e.g. manually via their names in a vector (left) or via a function such as `is.numeric` (right):\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl2 %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  mutate(\n    across(c(v1, v2), ~ .x + 20)\n    )\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl2 %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  mutate(\n    across(where(is.numeric), ~ .x + 20)\n    )\n```\n:::\n:::\n\n::: custom-callout-addref\n-   [5.5 Add new variables with mutate()](https://r4ds.had.co.nz/transform.html#add-new-variables-with-mutate) in *R for data science* [@Wickham_2017]\n-   [Create, modify, and delete columns with mutate()](https://dplyr.tidyverse.org/reference/mutate.html)\n-   [A general vectorised if with case_when()](https://dplyr.tidyverse.org/reference/case_when.html)\n-   [Apply a function (or functions) across multiple columns with across()](https://dplyr.tidyverse.org/reference/across.html)\n:::\n\n## select()\n\nThis function is useful whenever you want to select a subset of columns or change the order of columns. To provide better examples, let's first create a table `tbl3` with a few more columns:\n\n```{r}\ntbl3 <- tbl2 %>% \n  mutate(var1 = 1, var2 = 2, var3 = \"text\", var4 = \"word\")\n\ntbl3\n```\n\nWe can now select individual columns manually by giving all names (left) and even select all columns `from:to` by writing a colon between them (right):\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl3 %>% \n  select(group, var1, var4)\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl3 %>% \n  select(group, var1:var4)\n```\n:::\n:::\n\nWe can also use functions like `starts_with()`, `ends_with()`, `contains()`, `matches()` and `num_range()` to select all columns based on their name:\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl3 %>% \n  select(contains(\"r\"))\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl3 %>%\n  select(num_range(\"var\", 1:3))\n```\n:::\n:::\n\nFinally, we can select based on a function like `is.numeric` via `where()` (left) or simply rearrange while keeping all columns by using `everything()` (right)\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl3 %>% \n  select(where(is.numeric))\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl3 %>% \n  select(var1, everything())\n```\n:::\n:::\n\n::: custom-callout-addref\n-   [5.4 Select columns with select()](https://r4ds.had.co.nz/transform.html#select) in *R for data science* [@Wickham_2017]\n-   [Subset columns using their names and types with select()](https://dplyr.tidyverse.org/reference/select.html)\n-   [Select variables that match a pattern with starts_with() etc.](https://tidyselect.r-lib.org/reference/starts_with.html)\n-   [Select variables with a function with where()](https://tidyselect.r-lib.org/reference/where.html)\n:::\n\n## filter()\n\nThis function is useful whenever you want to subset rows based on their values. Note that for the examples here, we use the original `tbl` with 30 observations.\n\nLet's immediately filter for two conditions: Observations that belong to group `trt2` **and** are larger than 6 (left); Observations that are larger than 6 **or** smaller than 4 (right):\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  filter(weight > 6 & group == \"trt2\")\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  filter(weight > 6 | weight < 4)\n```\n:::\n:::\n\nWe can also filter for values that **are not** of the `ctrl` group (left) or that are larger than the mean weight (right):\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  filter(group != \"ctrl\")\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  filter(weight > mean(weight))\n```\n:::\n:::\n\n::: custom-callout-addref\n-   [5.2 Filter rows with filter()](https://r4ds.had.co.nz/transform.html#filter-rows-with-filter) in *R for data science* [@Wickham_2017]\n-   [Subset rows using column values with filter()](https://dplyr.tidyverse.org/reference/filter.html)\n:::\n\n## arrange()\n\nThis function is useful whenever you want to sort rows based on their values. Note that for the examples here, we use the original `tbl` with 30 observations. You'll notice that I've added `print(n = Inf)` so that R shows all rows of our resulting tibble, since by default R will only show the first 10 rows if a tibble has more than 20 rows.\n\nWe can arrange by one column (left) or multiple columns (right). Note that by default values are sorted in ascending order, but this can be changed by using `desc()` (right). Furthermore, `NA` (= missing values) are always sorted to the end[^3], even when using `desc()`.\n\n[^3]: See the additional resources below if you want it differently.\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  arrange(weight) %>% \n  print(n = Inf)\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  arrange(group, desc(weight)) %>% \n  print(n = Inf)\n```\n:::\n:::\n\n::: custom-callout-addref\n-   [5.3 Arrange rows with arrange()](https://r4ds.had.co.nz/transform.html#arrange-rows-with-arrange) in *R for data science* [@Wickham_2017]\n-   [Arrange rows by column values with arrange()](https://dplyr.tidyverse.org/reference/arrange.html)\n-   [How to have NA's displayed first using arrange()](https://stackoverflow.com/a/25267681/8830099)\n:::\n\n## summarise()\n\nThis function can be useful whenever you want to summarise data. Yet, it is not very useful (left) unless it is paired with `group_by()` (right).\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  # no group_by \n  summarise(my_mean = mean(weight))\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  group_by(group) %>% \n  summarise(my_mean = mean(weight))\n```\n:::\n:::\n\nYou can create multiple summary output columns (left) and have multiple grouping columns (right):\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  group_by(group) %>% \n  summarise(\n    Mean = mean(weight),\n    StdDev = sd(weight),\n    Min = min(weight),\n    Median = median(weight),\n    Max = max(weight),\n    n_Obs = n(),\n  )\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl %>% \n  mutate(larger5 = case_when(\n    weight > 5 ~ \"yes\",\n    weight < 5 ~ \"no\"\n  )) %>% \n  group_by(group, larger5) %>% \n  summarise(\n    n_Obs = n(),\n    Mean = mean(weight)\n  )\n```\n:::\n:::\n\nJust like with `mutate()`, we can make use of `across()` to deal with multiple columns:\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\ntbl %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  group_by(group) %>%\n  summarise(across(\n    where(is.numeric), \n    ~ mean(.x)\n    ))\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\ntbl %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  group_by(group) %>%\n  summarise(across(\n    c(weight, v3),\n    list(\n    Min = ~ min(.x),\n    Max = ~ max(.x)\n    )\n  ))\n```\n:::\n:::\n\n::: callout-important\nOnce you used `group_by()` on a table, it stays grouped unless you use `ungroup()` on it afterwards. This was not relevant in the examples above, but you must be aware of this if you are using the grouped (summary) results for further steps, since this can lead to unexpected results. You can find an example and further resources on such unintended outcomes [here](https://twitter.com/SchmidtPaul1989/status/1586284894556418049).\n:::\n\n::: custom-callout-addref\n-   [5.6 Grouped summaries with summarise()](https://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarise) in *R for data science* [@Wickham_2017]\n-   [Summarise each group to fewer rows with summarise()](https://dplyr.tidyverse.org/reference/summarise.html)\n-   [Group by one or more variables with group_by()](https://dplyr.tidyverse.org/reference/group_by.html)\n:::\n\n# long/wide format\n\nSometimes, data is referred to as being in *long format* or *wide format*. As the name suggests, long formatted tables have more rows, but fewer columns than wide formatted tables, while containing the same information. I find the easiest way to understand the two is by looking at examples like in the following image, which was taken from [statology.org](https://www.statology.org/long-vs-wide-data/) [-@LongWideStatology]:\n\n```{r}\n#| echo: false\n#| fig-align: center\n#| out-width: '80%'\nhere::here(\"img\", \"longwide.png\") %>% \n  knitr::include_graphics()\n```\n\nConverting one format into the other is called *pivoting* in the tidyverse and the relevant functions `pivot_longer()` and `pivot_wider()` are provided in [{tidyr}](https://tidyr.tidyverse.org/reference/index.html).\n\n::: callout-note\nYou may have used other functions in this context. Here are some alternatives that [are superseded](https://github.com/tidyverse/tidyr#related-work):\n\n-   `melt()` & `dcast()` of {data.table}\n-   `fold()` & `unfold()` of {databases}\n-   `melt()` & `cast()` of {reshape}\n-   `melt()` & `dcast()` of {reshape2}\n-   `unpivot()` & `pivot()` of {spreadsheets}\n-   `gather()` & `spread()` of {tidyr} \\< v1.0.0\n:::\n\nThe `PlantGrowth` data from above is actually already in long format, yet I create a version of it that is shorter (only 3 instead of 10 observations per group) and has an additional column called `nr` with is a running number per observation in each group:\n\n```{r}\nlong_dat <- PlantGrowth %>%\n  group_by(group) %>% # for each level in the \"group\" column\n  slice(1:3) %>% # keep only the rows 1-3\n  mutate(nr = 1:n(), # add a \"nr\" column with numbers 1 - ...\n         .before = \"weight\") %>% # add this column left of \"weight\" column\n  ungroup() # remove the grouping from above\n```\n\nWe can now use `pivot_wider()` and create a wide formatted version of the `long_dat` table and save it as `wide_dat`. Note that the function has multiple arguments you can use, but for me it is usually enough to use `names from =` and `values_from =`. In the former you provide the name of the column whose entries should be the names of the new columns in the wide formatted data. In the latter you provide the name of the column whose values should be written in the new columns in the wide formatted data:\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\nlong_dat\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\nwide_dat <- long_dat %>%\n  pivot_wider(names_from = \"group\", \n              values_from = \"weight\")\n\nwide_dat\n```\n:::\n:::\n\nWe can use `pivot_longer` to reverse the step above, i.e. create a long formatted version of the `wide_dat` table. Again, the function has multiple arguments you can use, but for me it is usually enough to use `cols =`, `names_to =` and `values_to =`. In the first one, you provide the names of the columns who should be reduced to fewer columns with more rows. In the other two you simply give the names that the created columns should have instead of the default `name` and `value`. Note that it is sometimes easier to provide the names of columns that should not go into `cols =` (right) instead of the ones that should (left).\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\nwide_dat %>%\n  pivot_longer(\n    cols = c(ctrl, trt1, trt2),\n    names_to = \"group\",\n    values_to = \"weight\"\n  )\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\nwide_dat %>%\n  pivot_longer(\n    cols = -nr,\n    names_to = \"group\",\n    values_to = \"weight\"\n  )\n```\n:::\n:::\n\n::: custom-callout-addref\n-   [12.3 Pivoting](https://r4ds.had.co.nz/tidy-data.html?q=pivot#pivoting) in *R for data science* [@Wickham_2017]\n-   [Pivoting with tidyr](https://tidyr.tidyverse.org/articles/pivot.html)\n-   [tidyr cheat sheet](https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf)\n:::\n\n# forcats\n\nIn my experience, R beginners really only care about the difference between `factor` and `character` variables once the factor level order is not as they want it to be - typically on the x-axis of a plot. Luckily, [{forcats}](https://forcats.tidyverse.org/) can deal with this.\n\nIn the following example, we create a column `fct` that is a copy of the column `chr`, except that they are formatted as `factor` and `character`, respectively.\n\n```{r}\ndat <- tribble(\n     ~val,   ~chr,\n       10, \"Ctrl\", \n       15,    \"A\",\n        8,    \"B\"\n) %>% \n  mutate(fct = as.factor(chr))\n\nggplot(dat) +\n  aes(y = val, x = fct) +\n  geom_col()\n```\n\nEven though the data is sorted so that Ctrl is first, then A, then B, the x-Axis is sorted differently[^4]. This is because factor levels are always sorted alphabetically by default. We can reorder them via different functions in {forcats}:\n\n[^4]: It does not make a difference here, whether we put `x = chr` or `x = fct` in the ggplot statement.\n\n```{r}\ndat <- dat %>% \n  mutate(\n    fct2 = fct_relevel(fct, c(\"Ctrl\", \"A\", \"B\")),\n    fct3 = fct_reorder(fct, val, mean)\n    )\n\nstr(dat)\n```\n\nAbove are just two popular examples for sorting factor levels: `fct_relevel` sorts the levels manually by providing a vector with the level names in the order they should appear, while `fct_reorder` here sorts the levels according to their respective group mean[^5] of the values in the `val` column.\n\n[^5]: Yes, the mean in this example is not really a mean, since there is only one number per group.\n\nYou can see that it worked in the output of `str(dat)` above and in the plots below.\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\n#| fig-width: 5\n#| fig-height: 3\nggplot(dat) +\n  aes(y = val, x = fct2) +\n  geom_col()\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\n#| fig-width: 5\n#| fig-height: 3\nggplot(dat) +\n  aes(y = val, x = fct3) +\n  geom_col()\n```\n:::\n:::\n\n# stringr\n\nIn computer programming, a string is traditionally a sequence of characters (or *text* if you will). Taken directly from [the documentation](https://stringr.tidyverse.org/):\n\n> Strings are not glamorous, high-profile components of R, but they do play a big role in many data cleaning and preparation tasks. The stringr package provide a cohesive set of functions designed to make working with strings as easy as possible. If you're not familiar with strings, the best place to start is the [chapter on strings in R for Data Science](https://r4ds.had.co.nz/strings.html).\n\nBelow are some brief examples of [{stringr}](https://stringr.tidyverse.org/) functions I use regularly. To show what they can do, let's first create some strings[^6]:\n\n[^6]: Note that while I create two vectors in this example, this will work just as well with columns of a table via \\`table %\\>% mutate(new = stringrfunction(old))\\`\n\n```{r}\na_string <- \"  a  string with irregular  spaces. \"\nstrings <-c(\"String 1\", \"String Two\", \"third string\")\n```\n\nTo remove part of a string, use `str_remove()`. To replace it, use `str_replace()`.\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\nstrings %>% \n  str_remove(pattern = \"ing\")\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\nstrings %>%\n  str_replace(pattern = \"ing\",\n              replacement = \".\")\n```\n:::\n:::\n\nThe functions `str_trim()` and `str_squish()` help remove unnecessary spaces from strings. The former removes them only from from start and end, while the latter also reduces repeated whitespace inside a string.\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\na_string %>% \n  str_trim()\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\na_string %>% \n  str_squish()\n```\n:::\n:::\n\nFinally, you can check if a pattern appears in a string, or extract part of a string:\n\n::: columns\n::: {.column width=\"49%\"}\n```{r}\nstrings %>% \n  str_detect(pattern = \"Two\")\n```\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n```{r}\nstrings %>% \n  str_sub(start = 1, end = 4)\n```\n:::\n:::\n\n::: custom-callout-addref\n-   [14 Strings](https://r4ds.had.co.nz/strings.html) in *R for data science* [@Wickham_2017]\n-   [stringr cheat sheet](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf)\n-   [Regular expressions](https://stringr.tidyverse.org/articles/regular-expressions.html)\n:::\n"},"formats":{"html":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"retina","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["../src/custom-callout-addref.lua","../src/custom-callout-modass.lua"],"css":["../styles.css"],"toc":true,"output-file":"tidyverse.html"},"language":{"code-summary":"Click to show/hide code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.189","author":[{"name":{"given":"Paul","family":"Schmidt","literal":"Paul Schmidt"},"orcid":"0000-0003-1528-2082","email":"schmidtpaul1989@outlook.com","affiliations":[{"name":"Freelancer &","url":"https://schmidtpaul.github.io/"},{"name":"BioMath GmbH","city":"Hamburg","country":"Germany","url":"https://www.biomath.de/"}]}],"editor":"visual","abstract-title":"Content summary","bibliography":["../references.bib"],"theme":"../theme.scss","code-copy":true,"citations-hover":true,"footnotes-hover":true,"title":"The tidyverse","date":"2022-10-09","abstract":"Pipe (%>%), Tibbles, dplyr-verbs, long/wide format and more from the tidyverse."},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","filters":["../src/custom-callout-addref.lua","../src/custom-callout-modass.lua"],"toc":true,"number-sections":true,"output-file":"tidyverse.pdf"},"language":{},"metadata":{"block-headings":true,"author":[{"name":{"given":"Paul","family":"Schmidt","literal":"Paul Schmidt"},"orcid":"0000-0003-1528-2082","email":"schmidtpaul1989@outlook.com","affiliations":[{"name":"Freelancer &","url":"https://schmidtpaul.github.io/"},{"name":"BioMath GmbH","city":"Hamburg","country":"Germany","url":"https://www.biomath.de/"}]}],"editor":"visual","abstract-title":"Content summary","bibliography":["../references.bib"],"colorlinks":true,"title":"The tidyverse","date":"2022-10-09","abstract":"Pipe (%>%), Tibbles, dplyr-verbs, long/wide format and more from the tidyverse."},"extensions":{"book":{}}}}}