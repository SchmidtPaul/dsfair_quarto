{
  "hash": "2737479ff079dc43fc12bdc2b16e9cc4",
  "result": {
    "markdown": "---\ntitle: \"The tidyverse\"\ndate: 2022-10-04\ncode-fold: false\nbibliography: references.bib\n---\n\n\n\n\n\nWhen using R, you will sooner or later hear about the [{tidyverse}](https://www.wikiwand.com/en/Tidyverse). The tidyverse is a collection of R packages that \"share an underlying design philosophy, grammar, and data structures\" of tidy data. The individual tidyverse packages comprise some of the most downloaded R packages.\n\nInstall the complete tidyverse with:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n# or\npacman::p_load(\"tidyverse\")\n```\n:::\n\n\n\n|                                                                 ggplot2                                                                  |                                                                dplyr                                                                 |                                                                 tibble                                                                 |                                                                 forcats                                                                  |                                                                 stringr                                                                  |\n|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|\n| [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/ggplot2.png\" width=\"100\"/>](https://ggplot2.tidyverse.org/) | [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/dplyr.png\" width=\"100\"/>](https://dplyr.tidyverse.org/) | [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/tibble.png\" width=\"100\"/>](https://tibble.tidyverse.org/) | [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/forcats.png\" width=\"100\"/>](https://forcats.tidyverse.org/) | [<img src=\"https://raw.githubusercontent.com/rstudio/hex-stickers/master/PNG/stringr.png\" width=\"100\"/>](https://stringr.tidyverse.org/) |\n\n: Some of my favorite tidyverse packages\n\nI did not use the tidyverse packages in my first years using R, but I wish I did. While you can often reach your goal with or without using the tidyverse packages, I personally prefer using them. Thus, they are used extensively throughout the chapters of this website.\n\nDuring the next sections I will try to explain how to use some of these packages and sometimes compare them to the Base R (= non-tidyverse) alternative.\n\n::: custom-callout-tip\n-    [\"R for Data Science\"](https://r4ds.had.co.nz/) [@Wickham_2017], which is a book that can be read online for free and was written by the package authors themselves.\n:::\n\n# Tables\n\nFinally, we can now talk about data tables with rows and columns. In R, I like to think of a table as multiple vectors side by side, so that each column is a vector.\n\n## data.frame\n\nBase R has a standard format for data tables called `data.frame`. Here is an example table that is an R built-in, just like `pi` is - it is called `PlantGrowth`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPlantGrowth\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n   weight group\n1    4.17  ctrl\n2    5.58  ctrl\n3    5.18  ctrl\n4    6.11  ctrl\n5    4.50  ctrl\n6    4.61  ctrl\n7    5.17  ctrl\n8    4.53  ctrl\n9    5.33  ctrl\n10   5.14  ctrl\n11   4.81  trt1\n12   4.17  trt1\n13   4.41  trt1\n14   3.59  trt1\n15   5.87  trt1\n16   3.83  trt1\n17   6.03  trt1\n18   4.89  trt1\n19   4.32  trt1\n20   4.69  trt1\n21   6.31  trt2\n22   5.12  trt2\n23   5.54  trt2\n24   5.50  trt2\n25   5.37  trt2\n26   5.29  trt2\n27   4.92  trt2\n28   6.15  trt2\n29   5.80  trt2\n30   5.26  trt2\n```\n:::\n:::\n\n\n\nLet us create a copy of this table called `df` (**d**ata**f**rame) and then use some helpful functions to get a first impression of this data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- PlantGrowth\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n'data.frame':\t30 obs. of  2 variables:\n $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n\n```{.r .cell-code}\nsummary(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n```\n:::\n:::\n\n\n\nWe can see that this dataset has 30 observations (=rows) and 2 variables (=columns) and is of the type \"data.frame\". Furthermore, the first variable is called `weight` and contains numeric values for which we get some measures of central tendency like the minimum, maximum, mean and median. The second variable is called `group` and is of the type factor containing a total of three different levels, which each appear 10 times.\n\nIf you want to extract/use values of only one column of such a data.frame, you write the name of the data.frame, then a `$` and finally the name of the respective column. It returns the values of that column as a vector:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$weight\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n[16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n```\n:::\n\n```{.r .cell-code}\ndf$group\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n[16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\nLevels: ctrl trt1 trt2\n```\n:::\n:::\n\n\n\n## tibble\n\nOne major aspect of the tidyverse is formatting tables as **tibble instead of data.frame**. A tibble *\"is a modern reimagining of the data.frame, keeping what time has proven to be effective, and throwing out what is not.\"* It is super simple to convert a data.frame into a tibble, but you must have the tidyverse R package {tibble} installed and loaded - which it is if you are loading the entire {tidyverse}. Let us convert our `df` into a tibble and call it `tbl`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse)\ntbl <- as_tibble(df)\ntbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 30 x 2\n   weight group\n    <dbl> <fct>\n 1   4.17 ctrl \n 2   5.58 ctrl \n 3   5.18 ctrl \n 4   6.11 ctrl \n 5   4.5  ctrl \n 6   4.61 ctrl \n 7   5.17 ctrl \n 8   4.53 ctrl \n 9   5.33 ctrl \n10   5.14 ctrl \n# ... with 20 more rows\n```\n:::\n:::\n\n\n\nOf course, the data itself does not change - only its format and the way it is displayed to us in R. If you compare the output we get from printing `tbl` here to that of printing `df` above, I would like to point out some things I find extremely convenient for tibbles:\n\n1.  There is an extra first line telling us about the number of rows and columns.\n2.  There is an extra line below the column names telling us about the data type of each column.\n3.  Only the first ten rows of data are printed and a *\"... with 20 more rows\"* is added below.\n4.  It can't be seen here, but this would analogously happen if there were too many columns.\n5.  It can't be seen here, but missing values `NA` and negative numbers are printed in red.\n\nFinally, note that in its heart, a tibble is still a data.frame and in most cases you can do everything with a tibble that you can do with a data.frame:\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code .code-overflow-wrap}\nclass(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n:::\n\n```{.r .cell-code .code-overflow-wrap}\nstr(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\ntibble [30 x 2] (S3: tbl_df/tbl/data.frame)\n $ weight: num [1:30] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n\n```{.r .cell-code .code-overflow-wrap}\nsummary(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n```\n:::\n\n```{.r .cell-code .code-overflow-wrap}\ntbl$weight\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n[16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n```\n:::\n\n```{.r .cell-code .code-overflow-wrap}\ntbl$group\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n[16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\nLevels: ctrl trt1 trt2\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code .code-overflow-wrap}\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"data.frame\"\n```\n:::\n\n```{.r .cell-code .code-overflow-wrap}\nstr(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n'data.frame':\t30 obs. of  2 variables:\n $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n\n```{.r .cell-code .code-overflow-wrap}\nsummary(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n```\n:::\n\n```{.r .cell-code .code-overflow-wrap}\ndf$weight\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n[16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n```\n:::\n\n```{.r .cell-code .code-overflow-wrap}\ndf$group\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n[16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\nLevels: ctrl trt1 trt2\n```\n:::\n:::\n\n\n:::\n:::\n\nTherefore, I almost always format my datasets as tibbles.\n\n# Plots\n\nBase R has a `plot()` function which is good at getting some first data visualizations with very little code. It guesses what type of plot you would like to see via the data type of the respective data to be plotted:\n\n\n\n::: {.cell layout-ncol=\"3\"}\n\n```{.r .cell-code}\nplot(df$weight) # scatter plot of values in the order they appear\n```\n\n::: {.cell-output-display}\n![](tidyverse_files/figure-pdf/unnamed-chunk-9-1.pdf)\n:::\n\n```{.r .cell-code}\nplot(df$group) # bar plot of frequency of each level\n```\n\n::: {.cell-output-display}\n![](tidyverse_files/figure-pdf/unnamed-chunk-9-2.pdf)\n:::\n\n```{.r .cell-code}\nplot(x = df$group, y = df$weight) # boxplot for values of each level\n```\n\n::: {.cell-output-display}\n![](tidyverse_files/figure-pdf/unnamed-chunk-9-3.pdf)\n:::\n:::\n\n\n\nHowever, I really just use `plot()` to get a quick first glance at data. In order to get professional visualizations I always use the tidyverse package `{ggplot2}` and its function `ggplot()`. It seems like it can create any plot you can imagine and there are multiple examples with increasing complexity spread out through this website's chapters.\n\n::: custom-callout-tip\n-   Cédric Scherer's [-@CedricScherer_2022] [A ggplot2 tutorial for beautiful plotting in R](https://www.cedricscherer.com/2019/08/05/a-ggplot2-tutorial-for-beautiful-plotting-in-r/)\n-   [ggplot2 extensions gallery](https://exts.ggplot2.tidyverse.org/gallery/)\n:::\n\n# The pipe operator\n\nThe pipe operator *\"completely changed the way how we code in R, making it more simple and readable\"* [@álvarez_2021]. I started using the pipe as `%>%` from the {dplyr} package[^1]. However, since May 18, 2021 (= R 4.1.0) the pipe is officially part of Base R - although written as `|>`[^2].\n\n[^1]: But it was not the first package to use it. [This blog post](http://adolfoalvarez.cl/blog/2021-09-16-plumbers-chains-and-famous-painters-the-history-of-the-pipe-operator-in-r/) has a nice summary of the history of the pipe operator in R.\n\n[^2]: Note that there are some differences between `%>%` and `|>` - find more about it *e.g.* [here](http://adolfoalvarez.cl/blog/2021-09-16-plumbers-chains-and-famous-painters-the-history-of-the-pipe-operator-in-r/#base-r).\n\nTo understand what makes it so great we need to start using more than one function at a time. So far, we have only used functions individually. Yet, in real life you will often find yourself having to combine multiple functions. As a fictional example, let's say that from the `PlantGrowth` data, we want to extract a sorted vector of the square root of all weight-values that belong to the `ctrl` group. I will show three approaches how to accomplish this\n\n## No pipe - intermediate steps\n\nUsing one function at a time and saving the output in the variables `a` - `d`, we can do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- filter(PlantGrowth, group == \"ctrl\")\nb <- pull(a, weight) # same as: b <- a$weight\nc <- sqrt(b)\nd <- round(c, digits = 1)\nsort(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 2.0 2.1 2.1 2.1 2.3 2.3 2.3 2.3 2.4 2.5\n```\n:::\n:::\n\n\n\n## No pipe - nesting functions\n\nJust like in MS Excel, it is possible to write functions inside of functions so that we can do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(round(sqrt(pull(filter(PlantGrowth, group == \"ctrl\"), weight)), digits = 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 2.0 2.1 2.1 2.1 2.3 2.3 2.3 2.3 2.4 2.5\n```\n:::\n:::\n\n\n\n## Pipe!\n\nThis approach (i) allows you to write functions from left to right / top to bottom and thus in the order they are executed and the way you think about them and (ii) does not create extra variables for intermediate steps:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nPlantGrowth %>% \n  filter(group == \"ctrl\") %>% \n  pull(weight) %>% \n  sqrt() %>% \n  round(digits = 1) %>% \n  sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 2.0 2.1 2.1 2.1 2.3 2.3 2.3 2.3 2.4 2.5\n```\n:::\n:::\n\n\n\nYou can think about it like this: Something (in this case the `PlantGrowth` data.frame) goes into the pipe and is directed to the next function `filter()`. By default, this function takes what came out of the previous pipe and puts it as its first argument. This happens with every pipe. You'll notice that all the functions who required two arguments above, now only need one argument, *i.e.* the additional argument, because the main argument stating which data is to be used is by default simply what came out of the previous pipe. Accordingly, the functions `sqrt()` and `sort()` appear empty here, because they only need one piece of information and that is which data they should work with. Finally note that you can easily highlight only some of the lines up until one of the pipes to see the intermediate results.\n\n::: callout-note\nThe keyboard shortcut for writing `%>%` in RStudio is **CTRL+SHIFT+M**. Keyboard shortcuts can be customized in RStudio as described [here](https://support.rstudio.com/hc/en-us/articles/206382178-Customizing-Keyboard-Shortcuts-in-the-RStudio-IDE).\n:::\n\n# dplyr verbs\n\nTaken directly from [the documentation](https://dplyr.tidyverse.org/):\n\n> {dplyr} is a grammar of data manipulation, providing a consistent set of verbs that help you solve the most common data manipulation challenges:\n>\n> -   `mutate()` adds new variables that are functions of existing variables.\n>\n> -   `select()` picks variables based on their names.\n>\n> -   `filter()` picks cases based on their values.\n>\n> -   `summarise()` reduces multiple values down to a single summary.\n>\n> -   `arrange()` changes the ordering of the rows.\n>\n> These all combine naturally with `group_by()` which allows you to perform any operation \"by group\". If you are new to dplyr, the best place to start is [the data transformation chapter](https://r4ds.had.co.nz/transform.html) in *R for data science* [@Wickham_2017].\n\nIn my experience you really can do most of the data manipulation before and after the actual statistics with these functions. In other words, it is exactly these functions who can and should replace the manual work you may currently even be doing in MS Excel. In the following sections I will give very brief examples of how to use these functions while always pointing to more thorough resources.\n\n## mutate()\n\nThis function is useful whenever you want to change existing columns or add new columns to your table. To keep the following examples short and simple, let's create `tbl2` as only the first six rows of `tbl` via the `head()` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl2 <- head(tbl)\ntbl2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 2\n  weight group\n   <dbl> <fct>\n1   4.17 ctrl \n2   5.58 ctrl \n3   5.18 ctrl \n4   6.11 ctrl \n5   4.5  ctrl \n6   4.61 ctrl \n```\n:::\n:::\n\n\n\nLet's start by adding 2 to the `weight` in our data. Below, we do this two different ways: by adding a column named `new` to the dataset (left) and by replacing/overwriting the original `weight` column (right):\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl2 %>% \n  mutate(new = weight + 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 3\n  weight group   new\n   <dbl> <fct> <dbl>\n1   4.17 ctrl   6.17\n2   5.58 ctrl   7.58\n3   5.18 ctrl   7.18\n4   6.11 ctrl   8.11\n5   4.5  ctrl   6.5 \n6   4.61 ctrl   6.61\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl2 %>% \n  mutate(weight = weight + 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 2\n  weight group\n   <dbl> <fct>\n1   6.17 ctrl \n2   7.58 ctrl \n3   7.18 ctrl \n4   8.11 ctrl \n5   6.5  ctrl \n6   6.61 ctrl \n```\n:::\n:::\n\n\n:::\n:::\n\nWe can also create multiple columns at once (left) and make the values of the new column dynamically depend on the other columns via `case_when()` (right):\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl2 %>%\n  mutate(\n    `Name with Space` = \"Hello!\",\n    number10 = 10\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 4\n  weight group `Name with Space` number10\n   <dbl> <fct> <chr>                <dbl>\n1   4.17 ctrl  Hello!                  10\n2   5.58 ctrl  Hello!                  10\n3   5.18 ctrl  Hello!                  10\n4   6.11 ctrl  Hello!                  10\n5   4.5  ctrl  Hello!                  10\n6   4.61 ctrl  Hello!                  10\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl2 %>% \n  mutate(larger5 = case_when(\n    weight > 5 ~ \"yes\",\n    weight < 5 ~ \"no\"\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 3\n  weight group larger5\n   <dbl> <fct> <chr>  \n1   4.17 ctrl  no     \n2   5.58 ctrl  yes    \n3   5.18 ctrl  yes    \n4   6.11 ctrl  yes    \n5   4.5  ctrl  no     \n6   4.61 ctrl  no     \n```\n:::\n:::\n\n\n:::\n:::\n\nFinally, we can efficiently apply the same function to multiple columns at once via `across()`. We can select the columns e.g. manually via their names in a vector (left) or via a function such as `is.numeric` (right):\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl2 %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  mutate(\n    across(c(v1, v2), ~ .x + 20)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 5\n  weight group    v1    v2    v3\n   <dbl> <fct> <dbl> <dbl> <dbl>\n1   4.17 ctrl     21    22     3\n2   5.58 ctrl     21    22     3\n3   5.18 ctrl     21    22     3\n4   6.11 ctrl     21    22     3\n5   4.5  ctrl     21    22     3\n6   4.61 ctrl     21    22     3\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl2 %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  mutate(\n    across(where(is.numeric), ~ .x + 20)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 5\n  weight group    v1    v2    v3\n   <dbl> <fct> <dbl> <dbl> <dbl>\n1   24.2 ctrl     21    22    23\n2   25.6 ctrl     21    22    23\n3   25.2 ctrl     21    22    23\n4   26.1 ctrl     21    22    23\n5   24.5 ctrl     21    22    23\n6   24.6 ctrl     21    22    23\n```\n:::\n:::\n\n\n:::\n:::\n\n::: custom-callout-tip\n-   [5.5 Add new variables with mutate()](https://r4ds.had.co.nz/transform.html#add-new-variables-with-mutate) in *R for data science* [@Wickham_2017]\n-   [Create, modify, and delete columns with mutate()](https://dplyr.tidyverse.org/reference/mutate.html)\n-   [A general vectorised if with case_when()](https://dplyr.tidyverse.org/reference/case_when.html)\n-   [Apply a function (or functions) across multiple columns with across()](https://dplyr.tidyverse.org/reference/across.html)\n:::\n\n## select()\n\nThis function is useful whenever you want to select a subset of columns or change the order of columns. To provide better examples, let's first create a table `tbl3` with a few more columns:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl3 <- tbl2 %>% \n  mutate(var1 = 1, var2 = 2, var3 = \"text\", var4 = \"word\")\n\ntbl3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 6\n  weight group  var1  var2 var3  var4 \n   <dbl> <fct> <dbl> <dbl> <chr> <chr>\n1   4.17 ctrl      1     2 text  word \n2   5.58 ctrl      1     2 text  word \n3   5.18 ctrl      1     2 text  word \n4   6.11 ctrl      1     2 text  word \n5   4.5  ctrl      1     2 text  word \n6   4.61 ctrl      1     2 text  word \n```\n:::\n:::\n\n\n\nWe can now select individual columns manually by giving all names (left) and even select all columns `from:to` by writing a colon between them (right):\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl3 %>% \n  select(group, var1, var4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 3\n  group  var1 var4 \n  <fct> <dbl> <chr>\n1 ctrl      1 word \n2 ctrl      1 word \n3 ctrl      1 word \n4 ctrl      1 word \n5 ctrl      1 word \n6 ctrl      1 word \n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl3 %>% \n  select(group, var1:var4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 5\n  group  var1  var2 var3  var4 \n  <fct> <dbl> <dbl> <chr> <chr>\n1 ctrl      1     2 text  word \n2 ctrl      1     2 text  word \n3 ctrl      1     2 text  word \n4 ctrl      1     2 text  word \n5 ctrl      1     2 text  word \n6 ctrl      1     2 text  word \n```\n:::\n:::\n\n\n:::\n:::\n\nWe can also use functions like `starts_with()`, `ends_with()`, `contains()`, `matches()` and `num_range()` to select all columns based on their name:\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl3 %>% \n  select(contains(\"r\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 5\n  group  var1  var2 var3  var4 \n  <fct> <dbl> <dbl> <chr> <chr>\n1 ctrl      1     2 text  word \n2 ctrl      1     2 text  word \n3 ctrl      1     2 text  word \n4 ctrl      1     2 text  word \n5 ctrl      1     2 text  word \n6 ctrl      1     2 text  word \n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl3 %>%\n  select(num_range(\"var\", 1:3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 3\n   var1  var2 var3 \n  <dbl> <dbl> <chr>\n1     1     2 text \n2     1     2 text \n3     1     2 text \n4     1     2 text \n5     1     2 text \n6     1     2 text \n```\n:::\n:::\n\n\n:::\n:::\n\nFinally, we can select based on a function like `is.numeric` via `where()` (left) or simply rearrange while keeping all columns by using `everything()` (right)\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl3 %>% \n  select(where(is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 3\n  weight  var1  var2\n   <dbl> <dbl> <dbl>\n1   4.17     1     2\n2   5.58     1     2\n3   5.18     1     2\n4   6.11     1     2\n5   4.5      1     2\n6   4.61     1     2\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl3 %>% \n  select(var1, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 6\n   var1 weight group  var2 var3  var4 \n  <dbl>  <dbl> <fct> <dbl> <chr> <chr>\n1     1   4.17 ctrl      2 text  word \n2     1   5.58 ctrl      2 text  word \n3     1   5.18 ctrl      2 text  word \n4     1   6.11 ctrl      2 text  word \n5     1   4.5  ctrl      2 text  word \n6     1   4.61 ctrl      2 text  word \n```\n:::\n:::\n\n\n:::\n:::\n\n::: custom-callout-tip\n-   [5.4 Select columns with select()](https://r4ds.had.co.nz/transform.html#select) in *R for data science* [@Wickham_2017]\n-   [Subset columns using their names and types with select()](https://dplyr.tidyverse.org/reference/select.html)\n-   [Select variables that match a pattern with starts_with() etc.](https://tidyselect.r-lib.org/reference/starts_with.html)\n-   [Select variables with a function with where()](https://tidyselect.r-lib.org/reference/where.html)\n:::\n\n## filter()\n\nThis function is useful whenever you want to subset rows based on their values. Note that for the examples here, we use the original `tbl` with 30 observations.\n\nLet's immediately filter for two conditions: Observations that belong to group `trt2` **and** are larger than 6 (left); Observations that are larger than 6 **or** smaller than 4 (right):\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  filter(weight > 6 & group == \"trt2\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 2 x 2\n  weight group\n   <dbl> <fct>\n1   6.31 trt2 \n2   6.15 trt2 \n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  filter(weight > 6 | weight < 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 2\n  weight group\n   <dbl> <fct>\n1   6.11 ctrl \n2   3.59 trt1 \n3   3.83 trt1 \n4   6.03 trt1 \n5   6.31 trt2 \n6   6.15 trt2 \n```\n:::\n:::\n\n\n:::\n:::\n\nWe can also filter for values that **are not** of the `ctrl` group (left) or that are larger than the mean weight (right):\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  filter(group != \"ctrl\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 20 x 2\n   weight group\n    <dbl> <fct>\n 1   4.81 trt1 \n 2   4.17 trt1 \n 3   4.41 trt1 \n 4   3.59 trt1 \n 5   5.87 trt1 \n 6   3.83 trt1 \n 7   6.03 trt1 \n 8   4.89 trt1 \n 9   4.32 trt1 \n10   4.69 trt1 \n11   6.31 trt2 \n12   5.12 trt2 \n13   5.54 trt2 \n14   5.5  trt2 \n15   5.37 trt2 \n16   5.29 trt2 \n17   4.92 trt2 \n18   6.15 trt2 \n19   5.8  trt2 \n20   5.26 trt2 \n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  filter(weight > mean(weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 17 x 2\n   weight group\n    <dbl> <fct>\n 1   5.58 ctrl \n 2   5.18 ctrl \n 3   6.11 ctrl \n 4   5.17 ctrl \n 5   5.33 ctrl \n 6   5.14 ctrl \n 7   5.87 trt1 \n 8   6.03 trt1 \n 9   6.31 trt2 \n10   5.12 trt2 \n11   5.54 trt2 \n12   5.5  trt2 \n13   5.37 trt2 \n14   5.29 trt2 \n15   6.15 trt2 \n16   5.8  trt2 \n17   5.26 trt2 \n```\n:::\n:::\n\n\n:::\n:::\n\n::: custom-callout-tip\n-   [5.2 Filter rows with filter()](https://r4ds.had.co.nz/transform.html#filter-rows-with-filter) in *R for data science* [@Wickham_2017]\n-   [Subset rows using column values with filter()](https://dplyr.tidyverse.org/reference/filter.html)\n:::\n\n## arrange()\n\nThis function is useful whenever you want to sort rows based on their values. Note that for the examples here, we use the original `tbl` with 30 observations. You'll notice that I've added `print(n = Inf)` so that R shows all rows of our resulting tibble, since by default R will only show the first 10 rows if a tibble has more than 20 rows.\n\nWe can arrange by one column (left) or multiple columns (right). Note that by default values are sorted in ascending order, but this can be changed by using `desc()` (right). Furthermore, `NA` (= missing values) are always sorted to the end[^3], even when using `desc()`.\n\n[^3]: See the additional resources below if you want it differently.\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  arrange(weight) %>% \n  print(n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 30 x 2\n   weight group\n    <dbl> <fct>\n 1   3.59 trt1 \n 2   3.83 trt1 \n 3   4.17 ctrl \n 4   4.17 trt1 \n 5   4.32 trt1 \n 6   4.41 trt1 \n 7   4.5  ctrl \n 8   4.53 ctrl \n 9   4.61 ctrl \n10   4.69 trt1 \n11   4.81 trt1 \n12   4.89 trt1 \n13   4.92 trt2 \n14   5.12 trt2 \n15   5.14 ctrl \n16   5.17 ctrl \n17   5.18 ctrl \n18   5.26 trt2 \n19   5.29 trt2 \n20   5.33 ctrl \n21   5.37 trt2 \n22   5.5  trt2 \n23   5.54 trt2 \n24   5.58 ctrl \n25   5.8  trt2 \n26   5.87 trt1 \n27   6.03 trt1 \n28   6.11 ctrl \n29   6.15 trt2 \n30   6.31 trt2 \n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  arrange(group, desc(weight)) %>% \n  print(n = Inf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 30 x 2\n   weight group\n    <dbl> <fct>\n 1   6.11 ctrl \n 2   5.58 ctrl \n 3   5.33 ctrl \n 4   5.18 ctrl \n 5   5.17 ctrl \n 6   5.14 ctrl \n 7   4.61 ctrl \n 8   4.53 ctrl \n 9   4.5  ctrl \n10   4.17 ctrl \n11   6.03 trt1 \n12   5.87 trt1 \n13   4.89 trt1 \n14   4.81 trt1 \n15   4.69 trt1 \n16   4.41 trt1 \n17   4.32 trt1 \n18   4.17 trt1 \n19   3.83 trt1 \n20   3.59 trt1 \n21   6.31 trt2 \n22   6.15 trt2 \n23   5.8  trt2 \n24   5.54 trt2 \n25   5.5  trt2 \n26   5.37 trt2 \n27   5.29 trt2 \n28   5.26 trt2 \n29   5.12 trt2 \n30   4.92 trt2 \n```\n:::\n:::\n\n\n:::\n:::\n\n::: custom-callout-tip\n-   [5.3 Arrange rows with arrange()](https://r4ds.had.co.nz/transform.html#arrange-rows-with-arrange) in *R for data science* [@Wickham_2017]\n-   [Arrange rows by column values with arrange()](https://dplyr.tidyverse.org/reference/arrange.html)\n-   [How to have NA's displayed first using arrange()](https://stackoverflow.com/a/25267681/8830099)\n:::\n\n## summarise()\n\nThis function can be useful whenever you want to summarise data. Yet, it is not very useful (left) unless it is paired with `group_by()` (right).\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  # no group_by \n  summarise(my_mean = mean(weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 1 x 1\n  my_mean\n    <dbl>\n1    5.07\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  group_by(group) %>% \n  summarise(my_mean = mean(weight))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 3 x 2\n  group my_mean\n  <fct>   <dbl>\n1 ctrl     5.03\n2 trt1     4.66\n3 trt2     5.53\n```\n:::\n:::\n\n\n:::\n:::\n\nYou can create multiple summary output columns (left) and have multiple grouping columns (right):\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  group_by(group) %>% \n  summarise(\n    Mean = mean(weight),\n    StdDev = sd(weight),\n    Min = min(weight),\n    Median = median(weight),\n    Max = max(weight),\n    n_Obs = n(),\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 3 x 7\n  group  Mean StdDev   Min Median   Max n_Obs\n  <fct> <dbl>  <dbl> <dbl>  <dbl> <dbl> <int>\n1 ctrl   5.03  0.583  4.17   5.15  6.11    10\n2 trt1   4.66  0.794  3.59   4.55  6.03    10\n3 trt2   5.53  0.443  4.92   5.44  6.31    10\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>% \n  mutate(larger5 = case_when(\n    weight > 5 ~ \"yes\",\n    weight < 5 ~ \"no\"\n  )) %>% \n  group_by(group, larger5) %>% \n  summarise(\n    n_Obs = n(),\n    Mean = mean(weight)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 6 x 4\n# Groups:   group [3]\n  group larger5 n_Obs  Mean\n  <fct> <chr>   <int> <dbl>\n1 ctrl  no          4  4.45\n2 ctrl  yes         6  5.42\n3 trt1  no          8  4.34\n4 trt1  yes         2  5.95\n5 trt2  no          1  4.92\n6 trt2  yes         9  5.59\n```\n:::\n:::\n\n\n:::\n:::\n\nJust like with `mutate()`, we can make use of `across()` to deal with multiple columns:\n\n::: columns\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  group_by(group) %>%\n  summarise(across(\n    where(is.numeric), \n    ~ mean(.x)\n    ))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 3 x 5\n  group weight    v1    v2    v3\n  <fct>  <dbl> <dbl> <dbl> <dbl>\n1 ctrl    5.03     1     2     3\n2 trt1    4.66     1     2     3\n3 trt2    5.53     1     2     3\n```\n:::\n:::\n\n\n:::\n\n::: {.column width=\"2%\"}\n:::\n\n::: {.column width=\"49%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  group_by(group) %>%\n  summarise(across(\n    c(weight, v3),\n    list(\n    Min = ~ min(.x),\n    Max = ~ max(.x)\n    )\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n# A tibble: 3 x 5\n  group weight_Min weight_Max v3_Min v3_Max\n  <fct>      <dbl>      <dbl>  <dbl>  <dbl>\n1 ctrl        4.17       6.11      3      3\n2 trt1        3.59       6.03      3      3\n3 trt2        4.92       6.31      3      3\n```\n:::\n:::\n\n\n\n:::\n:::\n\n::: callout-important\nOnce you used `group_by()` on a table, it stays grouped unless you use `ungroup()` on it afterwards. This was not relevant in the examples above, but you must be aware of this if you are using the grouped (summary) results for further steps, since this can lead to unexpected results.\n:::\n\n::: custom-callout-tip\n-   [5.6 Grouped summaries with summarise()](https://r4ds.had.co.nz/transform.html#grouped-summaries-with-summarise) in *R for data science* [@Wickham_2017]\n-   [Summarise each group to fewer rows with summarise()](https://dplyr.tidyverse.org/reference/summarise.html)\n-   [Group by one or more variables with group_by()](https://dplyr.tidyverse.org/reference/group_by.html)\n:::\n",
    "supporting": [
      "tidyverse_files\\figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}