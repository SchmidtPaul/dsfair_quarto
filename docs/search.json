[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Science for Agriculture in R",
    "section": "",
    "text": "DSFAIR - Data Science for Agriculture in R provides a cookbook with statistical analyses of typical examples in life sciences with focus on experimental agriculture, biology, ecology and other related fields."
  },
  {
    "objectID": "index.html#workshops",
    "href": "index.html#workshops",
    "title": "Data Science for Agriculture in R",
    "section": "Workshops",
    "text": "Workshops\nMoreover, the articles published here serve as the basis for any of my R‑Workshops. Check out\n\n“Prepare for an upcoming workshop”\nand my list of workshops"
  },
  {
    "objectID": "rbasics/firststeps.html",
    "href": "rbasics/firststeps.html",
    "title": "First steps in R",
    "section": "",
    "text": "This chapter is mostly aimed at people who are very new to R. However, people who do know R may still find useful insights from the sections where I emphasize how I use R.\nFurthermore, this tutorial teaches R the way I use it, which means you can do (and may have done) almost everything I do here with other code/functions/approaches. “The way I use it” mostly refers to me using the {tidyverse}, which “is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures” and has become quite popular over the last years. Here is a direct comparison of how to do things in R with base R and via the tidyverse."
  },
  {
    "objectID": "rbasics/firststeps.html#base-r",
    "href": "rbasics/firststeps.html#base-r",
    "title": "First steps in R",
    "section": "base R",
    "text": "base R\nAfter installing R there are many functions etc. you can use right away - which is what we did above. For example, when running ?mean, the help page will tell you that this function is part of the {base} package. As the name suggests, this package is built-in and its functions are ready to use the moment you have installed R. You can verify this by going to the “Packages” tab in RStudio - you will find the base package and it will have a checked box next to it."
  },
  {
    "objectID": "rbasics/firststeps.html#loading-packages",
    "href": "rbasics/firststeps.html#loading-packages",
    "title": "First steps in R",
    "section": "loading packages",
    "text": "loading packages\nWhen looking at the “Packages” tab in RStudio you may notice that some packages are listed, but do not have a check mark in the box next to them. These are packages that are installed, but not loaded. When a package is not loaded, its functions cannot be used. In order to load a package, the default command is library(package_name). This command must be run once every time you open a new R session."
  },
  {
    "objectID": "rbasics/firststeps.html#installing-additional-packages",
    "href": "rbasics/firststeps.html#installing-additional-packages",
    "title": "First steps in R",
    "section": "installing additional packages",
    "text": "installing additional packages\nR really shines because of the ability to install additional packages from external sources. Basically, anyone can create a function, put it in a package and make it available online. Some packages are very sophisticated and popular - e.g. the package ggplot2, which is not built-in, has been downloaded 75 million times. In order to install a package, the default command is install.packages(package_name). Alternatively, you can also click on the “Install” button in the top left of the “Packages” tab and type in the package_name there.\n\n\n\n\n\n\nNote\n\n\n\nA package only needs to be installed once, but\nA package must be loaded every time you open a new R session!\n\n\nHere is a curated list of R packages and tools for different areas."
  },
  {
    "objectID": "rbasics/firststeps.html#p_load-vs.-library",
    "href": "rbasics/firststeps.html#p_load-vs.-library",
    "title": "First steps in R",
    "section": "\np_load() vs. library()\n",
    "text": "p_load() vs. library()\n\n\nYou now know how to install and load R packages the standard way. However, over the years I switched to using the function p_load() from the {pacman} package instead of library() and install.packages(). The reason is simple: Usually R-scripts start with multiple lines of library() statements that load the necessary packages. However, when this code is run on a different computer, the user may not have all these packages installed and will therefore get an error message. This can be avoided by using the p_load(), because it\n\nloads all packages that are installed and\ninstalls and loads all packages that are not installed.\n\nObviously, {pacman} itself must first be installed (the standard way). Moreover, you may now think that in order to use p_load() we do need a single library(pacman) first. However, we can avoid this by writing pacman::p_load() instead. Simply put, writing package_name::function_name() makes sure that this explicit function from this explicit package is being used. Additionally, R actually lets you use this function without loading the corresponding package. Thus, we now arrived at the way I handle packages at the beginning of all my R-scripts:\n\npacman::p_load(\n  package_name_1,\n  package_name_2,\n  package_name_3\n)"
  },
  {
    "objectID": "rbasics/tidyverse.html",
    "href": "rbasics/tidyverse.html",
    "title": "The tidyverse",
    "section": "",
    "text": "When using R, you will sooner or later hear about the {tidyverse}. The tidyverse is a collection of R packages that “share an underlying design philosophy, grammar, and data structures” of tidy data. The individual tidyverse packages comprise some of the most downloaded R packages.\nInstall the complete tidyverse with:\nI did not use the tidyverse packages in my first years using R, but I wish I did. While you can often reach your goal with or without using the tidyverse packages, I personally prefer using them. Thus, they are used extensively throughout the chapters of this website.\nDuring the next sections I will try to explain how to use some of these packages and sometimes compare them to the Base R (= non-tidyverse) alternative."
  },
  {
    "objectID": "rbasics/tidyverse.html#data.frame",
    "href": "rbasics/tidyverse.html#data.frame",
    "title": "The tidyverse",
    "section": "data.frame",
    "text": "data.frame\nBase R has a standard format for data tables called data.frame. Here is an example table that is an R built-in, just like pi is - it is called PlantGrowth:\n\nPlantGrowth\n\n   weight group\n1    4.17  ctrl\n2    5.58  ctrl\n3    5.18  ctrl\n4    6.11  ctrl\n5    4.50  ctrl\n6    4.61  ctrl\n7    5.17  ctrl\n8    4.53  ctrl\n9    5.33  ctrl\n10   5.14  ctrl\n11   4.81  trt1\n12   4.17  trt1\n13   4.41  trt1\n14   3.59  trt1\n15   5.87  trt1\n16   3.83  trt1\n17   6.03  trt1\n18   4.89  trt1\n19   4.32  trt1\n20   4.69  trt1\n21   6.31  trt2\n22   5.12  trt2\n23   5.54  trt2\n24   5.50  trt2\n25   5.37  trt2\n26   5.29  trt2\n27   4.92  trt2\n28   6.15  trt2\n29   5.80  trt2\n30   5.26  trt2\n\n\nLet us create a copy of this table called df (dataframe) and then use some helpful functions to get a first impression of this data:\n\ndf <- PlantGrowth\nstr(df)\n\n'data.frame':   30 obs. of  2 variables:\n $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nsummary(df)\n\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n\n\nWe can see that this dataset has 30 observations (=rows) and 2 variables (=columns) and is of the type “data.frame”. Furthermore, the first variable is called weight and contains numeric values for which we get some measures of central tendency like the minimum, maximum, mean and median. The second variable is called group and is of the type factor containing a total of three different levels, which each appear 10 times.\nIf you want to extract/use values of only one column of such a data.frame, you write the name of the data.frame, then a $ and finally the name of the respective column. It returns the values of that column as a vector:\n\ndf$weight\n\n [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n[16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n\ndf$group\n\n [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n[16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\nLevels: ctrl trt1 trt2"
  },
  {
    "objectID": "rbasics/tidyverse.html#tibble",
    "href": "rbasics/tidyverse.html#tibble",
    "title": "The tidyverse",
    "section": "tibble",
    "text": "tibble\nOne major aspect of the tidyverse is formatting tables as tibble instead of data.frame. A tibble “is a modern reimagining of the data.frame, keeping what time has proven to be effective, and throwing out what is not.” It is super simple to convert a data.frame into a tibble, but you must have the tidyverse R package {tibble} installed and loaded - which it is if you are loading the entire {tidyverse}. Let us convert our df into a tibble and call it tbl:\n\npacman::p_load(tidyverse)\ntbl <- as_tibble(df)\ntbl\n\n# A tibble: 30 × 2\n   weight group\n    <dbl> <fct>\n 1   4.17 ctrl \n 2   5.58 ctrl \n 3   5.18 ctrl \n 4   6.11 ctrl \n 5   4.5  ctrl \n 6   4.61 ctrl \n 7   5.17 ctrl \n 8   4.53 ctrl \n 9   5.33 ctrl \n10   5.14 ctrl \n# … with 20 more rows\n\n\nOf course, the data itself does not change - only its format and the way it is displayed to us in R. If you compare the output we get from printing tbl here to that of printing df above, I would like to point out some things I find extremely convenient for tibbles:\n\nThere is an extra first line telling us about the number of rows and columns.\nThere is an extra line below the column names telling us about the data type of each column.\nOnly the first ten rows of data are printed and a “… with 20 more rows” is added below.\nIt can’t be seen here, but this would analogously happen if there were too many columns.\nIt can’t be seen here, but missing values NA and negative numbers are printed in red.\n\nFinally, note that in its heart, a tibble is still a data.frame and in most cases you can do everything with a tibble that you can do with a data.frame:\n\n\n\nclass(tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nstr(tbl)\n\ntibble [30 × 2] (S3: tbl_df/tbl/data.frame)\n $ weight: num [1:30] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nsummary(tbl)\n\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n\ntbl$weight\n\n [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n[16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n\ntbl$group\n\n [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n[16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\nLevels: ctrl trt1 trt2\n\n\n\n\n\n\nclass(df)\n\n[1] \"data.frame\"\n\nstr(df)\n\n'data.frame':   30 obs. of  2 variables:\n $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nsummary(df)\n\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n\ndf$weight\n\n [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n[16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n\ndf$group\n\n [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n[16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\nLevels: ctrl trt1 trt2\n\n\n\n\nTherefore, I almost always format my datasets as tibbles."
  },
  {
    "objectID": "rbasics/tidyverse.html#no-pipe---intermediate-steps",
    "href": "rbasics/tidyverse.html#no-pipe---intermediate-steps",
    "title": "The tidyverse",
    "section": "No pipe - intermediate steps",
    "text": "No pipe - intermediate steps\nUsing one function at a time and saving the output in the variables a - d, we can do this:\n\na <- filter(PlantGrowth, group == \"ctrl\")\nb <- pull(a, weight) # same as: b <- a$weight\nc <- sqrt(b)\nd <- round(c, digits = 1)\nsort(d)\n\n [1] 2.0 2.1 2.1 2.1 2.3 2.3 2.3 2.3 2.4 2.5"
  },
  {
    "objectID": "rbasics/tidyverse.html#no-pipe---nesting-functions",
    "href": "rbasics/tidyverse.html#no-pipe---nesting-functions",
    "title": "The tidyverse",
    "section": "No pipe - nesting functions",
    "text": "No pipe - nesting functions\nJust like in MS Excel, it is possible to write functions inside of functions so that we can do this:\n\nsort(round(sqrt(pull(filter(PlantGrowth, group == \"ctrl\"), weight)), digits = 1))\n\n [1] 2.0 2.1 2.1 2.1 2.3 2.3 2.3 2.3 2.4 2.5"
  },
  {
    "objectID": "rbasics/tidyverse.html#pipe",
    "href": "rbasics/tidyverse.html#pipe",
    "title": "The tidyverse",
    "section": "Pipe!",
    "text": "Pipe!\nThis approach (i) allows you to write functions from left to right / top to bottom and thus in the order they are executed and the way you think about them and (ii) does not create extra variables for intermediate steps:\n\nPlantGrowth %>% \n  filter(group == \"ctrl\") %>% \n  pull(weight) %>% \n  sqrt() %>% \n  round(digits = 1) %>% \n  sort()\n\n [1] 2.0 2.1 2.1 2.1 2.3 2.3 2.3 2.3 2.4 2.5\n\n\nYou can think about it like this: Something (in this case the PlantGrowth data.frame) goes into the pipe and is directed to the next function filter(). By default, this function takes what came out of the previous pipe and puts it as its first argument. This happens with every pipe. You’ll notice that all the functions who required two arguments above, now only need one argument, i.e. the additional argument, because the main argument stating which data is to be used is by default simply what came out of the previous pipe. Accordingly, the functions sqrt() and sort() appear empty here, because they only need one piece of information and that is which data they should work with. Finally note that you can easily highlight only some of the lines up until one of the pipes to see the intermediate results.\n\n\n\n\n\n\nNote\n\n\n\nThe keyboard shortcut for writing %>% in RStudio is CTRL+SHIFT+M. Keyboard shortcuts can be customized in RStudio as described here."
  },
  {
    "objectID": "rbasics/tidyverse.html#mutate",
    "href": "rbasics/tidyverse.html#mutate",
    "title": "The tidyverse",
    "section": "mutate()",
    "text": "mutate()\nThis function is useful whenever you want to change existing columns or add new columns to your table. To keep the following examples short and simple, let’s create tbl2 as only the first six rows of tbl via the head() function:\n\ntbl2 <- head(tbl)\ntbl2\n\n# A tibble: 6 × 2\n  weight group\n   <dbl> <fct>\n1   4.17 ctrl \n2   5.58 ctrl \n3   5.18 ctrl \n4   6.11 ctrl \n5   4.5  ctrl \n6   4.61 ctrl \n\n\nLet’s start by adding 2 to the weight in our data. Below, we do this two different ways: by adding a column named new to the dataset (left) and by replacing/overwriting the original weight column (right):\n\n\n\ntbl2 %>% \n  mutate(new = weight + 2)\n\n# A tibble: 6 × 3\n  weight group   new\n   <dbl> <fct> <dbl>\n1   4.17 ctrl   6.17\n2   5.58 ctrl   7.58\n3   5.18 ctrl   7.18\n4   6.11 ctrl   8.11\n5   4.5  ctrl   6.5 \n6   4.61 ctrl   6.61\n\n\n\n\n\n\ntbl2 %>% \n  mutate(weight = weight + 2)\n\n# A tibble: 6 × 2\n  weight group\n   <dbl> <fct>\n1   6.17 ctrl \n2   7.58 ctrl \n3   7.18 ctrl \n4   8.11 ctrl \n5   6.5  ctrl \n6   6.61 ctrl \n\n\n\n\nWe can also create multiple columns at once (left) and make the values of the new column dynamically depend on the other columns via case_when() (right):\n\n\n\ntbl2 %>%\n  mutate(\n    `Name with Space` = \"Hello!\",\n    number10 = 10\n  )\n\n# A tibble: 6 × 4\n  weight group `Name with Space` number10\n   <dbl> <fct> <chr>                <dbl>\n1   4.17 ctrl  Hello!                  10\n2   5.58 ctrl  Hello!                  10\n3   5.18 ctrl  Hello!                  10\n4   6.11 ctrl  Hello!                  10\n5   4.5  ctrl  Hello!                  10\n6   4.61 ctrl  Hello!                  10\n\n\n\n\n\n\ntbl2 %>% \n  mutate(larger5 = case_when(\n    weight > 5 ~ \"yes\",\n    weight < 5 ~ \"no\"\n  ))\n\n# A tibble: 6 × 3\n  weight group larger5\n   <dbl> <fct> <chr>  \n1   4.17 ctrl  no     \n2   5.58 ctrl  yes    \n3   5.18 ctrl  yes    \n4   6.11 ctrl  yes    \n5   4.5  ctrl  no     \n6   4.61 ctrl  no     \n\n\n\n\nFinally, we can efficiently apply the same function to multiple columns at once via across(). We can select the columns e.g. manually via their names in a vector (left) or via a function such as is.numeric (right):\n\n\n\ntbl2 %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  mutate(\n    across(c(v1, v2), ~ .x + 20)\n    )\n\n# A tibble: 6 × 5\n  weight group    v1    v2    v3\n   <dbl> <fct> <dbl> <dbl> <dbl>\n1   4.17 ctrl     21    22     3\n2   5.58 ctrl     21    22     3\n3   5.18 ctrl     21    22     3\n4   6.11 ctrl     21    22     3\n5   4.5  ctrl     21    22     3\n6   4.61 ctrl     21    22     3\n\n\n\n\n\n\ntbl2 %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  mutate(\n    across(where(is.numeric), ~ .x + 20)\n    )\n\n# A tibble: 6 × 5\n  weight group    v1    v2    v3\n   <dbl> <fct> <dbl> <dbl> <dbl>\n1   24.2 ctrl     21    22    23\n2   25.6 ctrl     21    22    23\n3   25.2 ctrl     21    22    23\n4   26.1 ctrl     21    22    23\n5   24.5 ctrl     21    22    23\n6   24.6 ctrl     21    22    23\n\n\n\n\n\n\n\n\n\n\nAdditional Resources (click to show)\n\n\n\n\n\n\n\n5.5 Add new variables with mutate() in R for data science (Wickham and Grolemund 2017)\n\nCreate, modify, and delete columns with mutate()\nA general vectorised if with case_when()\nApply a function (or functions) across multiple columns with across()"
  },
  {
    "objectID": "rbasics/tidyverse.html#select",
    "href": "rbasics/tidyverse.html#select",
    "title": "The tidyverse",
    "section": "select()",
    "text": "select()\nThis function is useful whenever you want to select a subset of columns or change the order of columns. To provide better examples, let’s first create a table tbl3 with a few more columns:\n\ntbl3 <- tbl2 %>% \n  mutate(var1 = 1, var2 = 2, var3 = \"text\", var4 = \"word\")\n\ntbl3\n\n# A tibble: 6 × 6\n  weight group  var1  var2 var3  var4 \n   <dbl> <fct> <dbl> <dbl> <chr> <chr>\n1   4.17 ctrl      1     2 text  word \n2   5.58 ctrl      1     2 text  word \n3   5.18 ctrl      1     2 text  word \n4   6.11 ctrl      1     2 text  word \n5   4.5  ctrl      1     2 text  word \n6   4.61 ctrl      1     2 text  word \n\n\nWe can now select individual columns manually by giving all names (left) and even select all columns from:to by writing a colon between them (right):\n\n\n\ntbl3 %>% \n  select(group, var1, var4)\n\n# A tibble: 6 × 3\n  group  var1 var4 \n  <fct> <dbl> <chr>\n1 ctrl      1 word \n2 ctrl      1 word \n3 ctrl      1 word \n4 ctrl      1 word \n5 ctrl      1 word \n6 ctrl      1 word \n\n\n\n\n\n\ntbl3 %>% \n  select(group, var1:var4)\n\n# A tibble: 6 × 5\n  group  var1  var2 var3  var4 \n  <fct> <dbl> <dbl> <chr> <chr>\n1 ctrl      1     2 text  word \n2 ctrl      1     2 text  word \n3 ctrl      1     2 text  word \n4 ctrl      1     2 text  word \n5 ctrl      1     2 text  word \n6 ctrl      1     2 text  word \n\n\n\n\nWe can also use functions like starts_with(), ends_with(), contains(), matches() and num_range() to select all columns based on their name:\n\n\n\ntbl3 %>% \n  select(contains(\"r\"))\n\n# A tibble: 6 × 5\n  group  var1  var2 var3  var4 \n  <fct> <dbl> <dbl> <chr> <chr>\n1 ctrl      1     2 text  word \n2 ctrl      1     2 text  word \n3 ctrl      1     2 text  word \n4 ctrl      1     2 text  word \n5 ctrl      1     2 text  word \n6 ctrl      1     2 text  word \n\n\n\n\n\n\ntbl3 %>%\n  select(num_range(\"var\", 1:3))\n\n# A tibble: 6 × 3\n   var1  var2 var3 \n  <dbl> <dbl> <chr>\n1     1     2 text \n2     1     2 text \n3     1     2 text \n4     1     2 text \n5     1     2 text \n6     1     2 text \n\n\n\n\nFinally, we can select based on a function like is.numeric via where() (left) or simply rearrange while keeping all columns by using everything() (right)\n\n\n\ntbl3 %>% \n  select(where(is.numeric))\n\n# A tibble: 6 × 3\n  weight  var1  var2\n   <dbl> <dbl> <dbl>\n1   4.17     1     2\n2   5.58     1     2\n3   5.18     1     2\n4   6.11     1     2\n5   4.5      1     2\n6   4.61     1     2\n\n\n\n\n\n\ntbl3 %>% \n  select(var1, everything())\n\n# A tibble: 6 × 6\n   var1 weight group  var2 var3  var4 \n  <dbl>  <dbl> <fct> <dbl> <chr> <chr>\n1     1   4.17 ctrl      2 text  word \n2     1   5.58 ctrl      2 text  word \n3     1   5.18 ctrl      2 text  word \n4     1   6.11 ctrl      2 text  word \n5     1   4.5  ctrl      2 text  word \n6     1   4.61 ctrl      2 text  word \n\n\n\n\n\n\n\n\n\n\nAdditional Resources (click to show)\n\n\n\n\n\n\n\n5.4 Select columns with select() in R for data science (Wickham and Grolemund 2017)\n\nSubset columns using their names and types with select()\nSelect variables that match a pattern with starts_with() etc.\nSelect variables with a function with where()"
  },
  {
    "objectID": "rbasics/tidyverse.html#filter",
    "href": "rbasics/tidyverse.html#filter",
    "title": "The tidyverse",
    "section": "filter()",
    "text": "filter()\nThis function is useful whenever you want to subset rows based on their values. Note that for the examples here, we use the original tbl with 30 observations.\nLet’s immediately filter for two conditions: Observations that belong to group trt2 and are larger than 6 (left); Observations that are larger than 6 or smaller than 4 (right):\n\n\n\ntbl %>% \n  filter(weight > 6 & group == \"trt2\")\n\n# A tibble: 2 × 2\n  weight group\n   <dbl> <fct>\n1   6.31 trt2 \n2   6.15 trt2 \n\n\n\n\n\n\ntbl %>% \n  filter(weight > 6 | weight < 4)\n\n# A tibble: 6 × 2\n  weight group\n   <dbl> <fct>\n1   6.11 ctrl \n2   3.59 trt1 \n3   3.83 trt1 \n4   6.03 trt1 \n5   6.31 trt2 \n6   6.15 trt2 \n\n\n\n\nWe can also filter for values that are not of the ctrl group (left) or that are larger than the mean weight (right):\n\n\n\ntbl %>% \n  filter(group != \"ctrl\")\n\n# A tibble: 20 × 2\n   weight group\n    <dbl> <fct>\n 1   4.81 trt1 \n 2   4.17 trt1 \n 3   4.41 trt1 \n 4   3.59 trt1 \n 5   5.87 trt1 \n 6   3.83 trt1 \n 7   6.03 trt1 \n 8   4.89 trt1 \n 9   4.32 trt1 \n10   4.69 trt1 \n11   6.31 trt2 \n12   5.12 trt2 \n13   5.54 trt2 \n14   5.5  trt2 \n15   5.37 trt2 \n16   5.29 trt2 \n17   4.92 trt2 \n18   6.15 trt2 \n19   5.8  trt2 \n20   5.26 trt2 \n\n\n\n\n\n\ntbl %>% \n  filter(weight > mean(weight))\n\n# A tibble: 17 × 2\n   weight group\n    <dbl> <fct>\n 1   5.58 ctrl \n 2   5.18 ctrl \n 3   6.11 ctrl \n 4   5.17 ctrl \n 5   5.33 ctrl \n 6   5.14 ctrl \n 7   5.87 trt1 \n 8   6.03 trt1 \n 9   6.31 trt2 \n10   5.12 trt2 \n11   5.54 trt2 \n12   5.5  trt2 \n13   5.37 trt2 \n14   5.29 trt2 \n15   6.15 trt2 \n16   5.8  trt2 \n17   5.26 trt2 \n\n\n\n\n\n\n\n\n\n\nAdditional Resources (click to show)\n\n\n\n\n\n\n\n5.2 Filter rows with filter() in R for data science (Wickham and Grolemund 2017)\n\nSubset rows using column values with filter()"
  },
  {
    "objectID": "rbasics/tidyverse.html#arrange",
    "href": "rbasics/tidyverse.html#arrange",
    "title": "The tidyverse",
    "section": "arrange()",
    "text": "arrange()\nThis function is useful whenever you want to sort rows based on their values. Note that for the examples here, we use the original tbl with 30 observations. You’ll notice that I’ve added print(n = Inf) so that R shows all rows of our resulting tibble, since by default R will only show the first 10 rows if a tibble has more than 20 rows.\nWe can arrange by one column (left) or multiple columns (right). Note that by default values are sorted in ascending order, but this can be changed by using desc() (right). Furthermore, NA (= missing values) are always sorted to the end3, even when using desc().\n\n\n\ntbl %>% \n  arrange(weight) %>% \n  print(n = Inf)\n\n# A tibble: 30 × 2\n   weight group\n    <dbl> <fct>\n 1   3.59 trt1 \n 2   3.83 trt1 \n 3   4.17 ctrl \n 4   4.17 trt1 \n 5   4.32 trt1 \n 6   4.41 trt1 \n 7   4.5  ctrl \n 8   4.53 ctrl \n 9   4.61 ctrl \n10   4.69 trt1 \n11   4.81 trt1 \n12   4.89 trt1 \n13   4.92 trt2 \n14   5.12 trt2 \n15   5.14 ctrl \n16   5.17 ctrl \n17   5.18 ctrl \n18   5.26 trt2 \n19   5.29 trt2 \n20   5.33 ctrl \n21   5.37 trt2 \n22   5.5  trt2 \n23   5.54 trt2 \n24   5.58 ctrl \n25   5.8  trt2 \n26   5.87 trt1 \n27   6.03 trt1 \n28   6.11 ctrl \n29   6.15 trt2 \n30   6.31 trt2 \n\n\n\n\n\n\ntbl %>% \n  arrange(group, desc(weight)) %>% \n  print(n = Inf)\n\n# A tibble: 30 × 2\n   weight group\n    <dbl> <fct>\n 1   6.11 ctrl \n 2   5.58 ctrl \n 3   5.33 ctrl \n 4   5.18 ctrl \n 5   5.17 ctrl \n 6   5.14 ctrl \n 7   4.61 ctrl \n 8   4.53 ctrl \n 9   4.5  ctrl \n10   4.17 ctrl \n11   6.03 trt1 \n12   5.87 trt1 \n13   4.89 trt1 \n14   4.81 trt1 \n15   4.69 trt1 \n16   4.41 trt1 \n17   4.32 trt1 \n18   4.17 trt1 \n19   3.83 trt1 \n20   3.59 trt1 \n21   6.31 trt2 \n22   6.15 trt2 \n23   5.8  trt2 \n24   5.54 trt2 \n25   5.5  trt2 \n26   5.37 trt2 \n27   5.29 trt2 \n28   5.26 trt2 \n29   5.12 trt2 \n30   4.92 trt2 \n\n\n\n\n\n\n\n\n\n\nAdditional Resources (click to show)\n\n\n\n\n\n\n\n5.3 Arrange rows with arrange() in R for data science (Wickham and Grolemund 2017)\n\nArrange rows by column values with arrange()\nHow to have NA’s displayed first using arrange()"
  },
  {
    "objectID": "rbasics/tidyverse.html#summarise",
    "href": "rbasics/tidyverse.html#summarise",
    "title": "The tidyverse",
    "section": "summarise()",
    "text": "summarise()\nThis function can be useful whenever you want to summarise data. Yet, it is not very useful (left) unless it is paired with group_by() (right).\n\n\n\ntbl %>% \n  # no group_by \n  summarise(my_mean = mean(weight))\n\n# A tibble: 1 × 1\n  my_mean\n    <dbl>\n1    5.07\n\n\n\n\n\n\ntbl %>% \n  group_by(group) %>% \n  summarise(my_mean = mean(weight))\n\n# A tibble: 3 × 2\n  group my_mean\n  <fct>   <dbl>\n1 ctrl     5.03\n2 trt1     4.66\n3 trt2     5.53\n\n\n\n\nYou can create multiple summary output columns (left) and have multiple grouping columns (right):\n\n\n\ntbl %>% \n  group_by(group) %>% \n  summarise(\n    Mean = mean(weight),\n    StdDev = sd(weight),\n    Min = min(weight),\n    Median = median(weight),\n    Max = max(weight),\n    n_Obs = n(),\n  )\n\n# A tibble: 3 × 7\n  group  Mean StdDev   Min Median   Max n_Obs\n  <fct> <dbl>  <dbl> <dbl>  <dbl> <dbl> <int>\n1 ctrl   5.03  0.583  4.17   5.15  6.11    10\n2 trt1   4.66  0.794  3.59   4.55  6.03    10\n3 trt2   5.53  0.443  4.92   5.44  6.31    10\n\n\n\n\n\n\ntbl %>% \n  mutate(larger5 = case_when(\n    weight > 5 ~ \"yes\",\n    weight < 5 ~ \"no\"\n  )) %>% \n  group_by(group, larger5) %>% \n  summarise(\n    n_Obs = n(),\n    Mean = mean(weight)\n  )\n\n# A tibble: 6 × 4\n# Groups:   group [3]\n  group larger5 n_Obs  Mean\n  <fct> <chr>   <int> <dbl>\n1 ctrl  no          4  4.45\n2 ctrl  yes         6  5.42\n3 trt1  no          8  4.34\n4 trt1  yes         2  5.95\n5 trt2  no          1  4.92\n6 trt2  yes         9  5.59\n\n\n\n\nJust like with mutate(), we can make use of across() to deal with multiple columns:\n\n\n\ntbl %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  group_by(group) %>%\n  summarise(across(\n    where(is.numeric), \n    ~ mean(.x)\n    ))\n\n# A tibble: 3 × 5\n  group weight    v1    v2    v3\n  <fct>  <dbl> <dbl> <dbl> <dbl>\n1 ctrl    5.03     1     2     3\n2 trt1    4.66     1     2     3\n3 trt2    5.53     1     2     3\n\n\n\n\n\n\ntbl %>%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %>%\n  group_by(group) %>%\n  summarise(across(\n    c(weight, v3),\n    list(\n    Min = ~ min(.x),\n    Max = ~ max(.x)\n    )\n  ))\n\n# A tibble: 3 × 5\n  group weight_Min weight_Max v3_Min v3_Max\n  <fct>      <dbl>      <dbl>  <dbl>  <dbl>\n1 ctrl        4.17       6.11      3      3\n2 trt1        3.59       6.03      3      3\n3 trt2        4.92       6.31      3      3\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nOnce you used group_by() on a table, it stays grouped unless you use ungroup() on it afterwards. This was not relevant in the examples above, but you must be aware of this if you are using the grouped (summary) results for further steps, since this can lead to unexpected results.\n\n\n\n\n\n\n\n\nAdditional Resources (click to show)\n\n\n\n\n\n\n\n5.6 Grouped summaries with summarise() in R for data science (Wickham and Grolemund 2017)\n\nSummarise each group to fewer rows with summarise()\nGroup by one or more variables with group_by()"
  },
  {
    "objectID": "summaryarticles/compactletterdisplay.html#get-the-letters",
    "href": "summaryarticles/compactletterdisplay.html#get-the-letters",
    "title": "Compact Letter Display (CLD)",
    "section": "get the letters",
    "text": "get the letters\nYou will need to install the packages emmeans, multcomp and {multcompView}. The example given here is based on the PlantGrowth data, which is included in R.\n\nClick to show/hide codelibrary(emmeans)\nlibrary(multcomp)\nlibrary(multcompView)\n\n# set up model\nmodel <- lm(weight ~ group, data = PlantGrowth)\n\n# get (adjusted) weight means per group\nmodel_means <- emmeans(object = model,\n                       specs = \"group\")\n\n# add letters to each mean\nmodel_means_cld <- cld(object = model_means,\n                       adjust = \"Tukey\",\n                       Letters = letters,\n                       alpha = 0.05)\n# show output\nmodel_means_cld\n\n\n\n\n group emmean    SE df lower.CL upper.CL .group\n trt1    4.66 0.197 27     4.16     5.16  a    \n ctrl    5.03 0.197 27     4.53     5.53  ab   \n trt2    5.53 0.197 27     5.02     6.03   b   \n\nConfidence level used: 0.95 \nConf-level adjustment: sidak method for 3 estimates \nP value adjustment: tukey method for comparing a family of 3 estimates \nsignificance level used: alpha = 0.05 \nNOTE: If two or more means share the same grouping letter,\n      then we cannot show them to be different.\n      But we also did not show them to be the same. \n\n\n\n\nWe set up a model\n\nThis is a very simple example using lm(). You may use much more complex models and many other model classes.\n\n\n\nemmeans() estimates adjusted means per group.\n\nNote that when doing this for mixed models, one should use the Kenward-Roger method adjusting the denominator degrees of freedom. One may add the lmer.df = \"kenward-roger\" argument, yet this is the default in {emmeans} (Details here)! Also note that you cannot go wrong with this adjustment - even if there is nothing to adjust.\n\n\n\ncld() adds the letters in a new column named .group.\n\nThe alpha = argument lets you choose the significance level for the comparisons.\nIt allows for different multiplicity adjustments. Go to the “P-value adjustments” heading within the “summary.emmGrid” section in the emmeans documentation for more details on e.g. t-test, Tukey-test, Bonferroni adjustment etc.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you get the following note and are irritated by it,\n\n## Note: adjust = \"tukey\" was changed to \"sidak\" \n## because \"tukey\" is only appropriate for one set of pairwise comparisons\n## Conf-level adjustment: sidak method for 3 estimates.\n## P value adjustment: tukey method for comparing a family of 3 estimates\n\nhere is an answer explaining why this happens and that it is not a problem. It is not a problem in the sense that the p-values of the pairwise comparisons were indeed adjusted with the Tukey-method, while the Sidak adjustment was applied to the confidence intervals of the means (i.e. columns lower.CL and upper.CL)."
  },
  {
    "objectID": "summaryarticles/compactletterdisplay.html#interpret-the-letters",
    "href": "summaryarticles/compactletterdisplay.html#interpret-the-letters",
    "title": "Compact Letter Display (CLD)",
    "section": "interpret the letters",
    "text": "interpret the letters\nUntil August 2022, the note below the cld() outcome would read:\n\n## NOTE: Compact letter displays can be misleading\n##       because they show NON-findings rather than findings.\n##       Consider using 'pairs()', 'pwpp()', or 'pwpm()' instead.\n\nHowever, in CRAN version 1.8.0 it was changed to:\n\n## NOTE: If two or more means share the same grouping letter,\n##       then we cannot show them to be different.\n##       But we also did not show them to be the same.\n\nBoth notes are very much in line with the delicate matter of how the CLD must be understood. The author and maintainer of the emmeans package, Russell V. Lenth makes the argument that CLDs convey information in a way that may be misleading to the reader. This is because they “display non-findings rather than findings - they group together means based on NOT being able to show they are different” (personal communication). Furthermore, “[the CLD approach] works, but it is very black-and-white: with alpha = .05, P values slightly above or below .05 make a difference, but there’s no difference between a P value of .051 and one of .987, or between .049 and .00001” (posted here). He even wrote here that “Providing for CLDs at all remains one of my biggest regrets in developing this package”. Finally, the former note suggests using alternative plots, which are also created below.\nOn the other hand, it must be clear that the information conveyed by CLDs is not wrong as long as it is interpreted correctly. The documentation of the cld() function refers to Piepho (2004), but even more on point in this context is Piepho (2018):\n\nPiepho, Hans-Peter (2018) Letters in Mean Comparisons: What They Do and Don’t Mean, Agronomy Journal, 110(2), 431-434. DOI: 10.2134/agronj2017.10.0580 (ResearchGate)\nAbstract\n\nLetter displays allow efficient reporting of pairwise treatment comparisons.\nIt is important to correctly convey the meaning of letters in captions to tables and graphs displaying treatment means.\nThe meaning of a letter display can and should be stated in a single sentence without ambiguity.\n\nLetter displays are often used to report results of all pairwise comparisons among treatment means in comparative experiments. In captions to tables and charts using such letter displays, it is crucial to explain properly what the letters mean. In this paper I explain what the letters mean and how this meaning can be succinctly conveyed in a single sentence without ambiguity. This is contrasted to counter-examples commonly found in publications.\n\nThus, the article (= 4 pages long) is certainly worth a read if you are using CLDs."
  },
  {
    "objectID": "summaryarticles/compactletterdisplay.html#get-the-plots",
    "href": "summaryarticles/compactletterdisplay.html#get-the-plots",
    "title": "Compact Letter Display (CLD)",
    "section": "get the plots",
    "text": "get the plots\nHere I provide code for two ways of plotting the results via ggplot2. The first plot is the one I would use, while the second plot is one that is traditionally more common. Finally, I provide examples of other plots that I came across that are suggested as alternatives to CLD plots.\nplot 1: suggested\nI’ve been using and suggesting to use this type of plot for a while now. I know it contains a lot of information and may seem unfamiliar and overwhelming at first glance. However, I argue that if you take the time to understand what you are looking at, this plot is nice as it shows the raw data (black dots), descriptive statistics (black boxes), estimated means (red dots) and a measure of their precision (red error bars) as well as the compact letter display (red letters).\n\nClick to show/hide codelibrary(ggtext)    # automatic line breaks in caption\nlibrary(tidyverse) # ggplot & helper functions\nlibrary(scales)    # more helper functions\n\n# optional: sort factor levels of groups column according to highest mean\n# ...in means table\nmodel_means_cld <- model_means_cld %>% \n  mutate(group = fct_reorder(group, emmean))\n# ...in data table\nPlantGrowth <- PlantGrowth %>% \n  mutate(group = fct_relevel(group, levels(model_means_cld$group)))\n\n# plot\nggplot() +\n  # y-axis\n  scale_y_continuous(\n    name = \"Weight\",\n    limits = c(0, NA),\n    breaks = pretty_breaks(),\n    expand = expansion(mult = c(0,0.1))\n  ) +\n  # x-axis\n  scale_x_discrete(\n    name = \"Treatment\"\n  ) +\n  # general layout\n  theme_classic() +\n  theme(plot.caption = element_textbox_simple()) +\n  # black data points\n  geom_point(\n    data = PlantGrowth,\n    aes(y = weight, x = group),\n    shape = 16,\n    alpha = 0.5,\n    position = position_nudge(x = -0.2)\n  ) +\n  # black boxplot\n  geom_boxplot(\n    data = PlantGrowth,\n    aes(y = weight, x = group),\n    width = 0.05,\n    outlier.shape = NA,\n    position = position_nudge(x = -0.1)\n  ) +\n  # red mean value\n  geom_point(\n    data = model_means_cld,\n    aes(y = emmean, x = group),\n    size = 2,\n    color = \"red\"\n  ) +\n  # red mean errorbar\n  geom_errorbar(\n    data = model_means_cld,\n    aes(ymin = lower.CL, ymax = upper.CL, x = group),\n    width = 0.05,\n    color = \"red\"\n  ) +\n  # red letters\n  geom_text(\n    data = model_means_cld,\n    aes(\n      y = emmean,\n      x = group,\n      label = str_trim(.group)\n    ),\n    position = position_nudge(x = 0.1),\n    hjust = 0,\n    color = \"red\"\n  ) +\n  # caption\n  labs(\n    caption = \"Black dots represent raw data. Red dots and error bars represent (estimated marginal) means ± 95% confidence interval per group. Means not sharing any letter are significantly different by the Tukey-test at the 5% level of significance.\"\n  )\n\n\n\n\nplot 2: well-known\nTraditionally, bar plots with error bars are used a lot in this context. In my experience, there is at least one poster with one of them in every university building I. While they are not wrong per se, there is a decade-long discussion about why such “dynamite plots” are not optimal (see e.g. this nice blogpost).\n\nClick to show/hide codelibrary(ggtext)    # automatic line breaks in caption\nlibrary(tidyverse) # ggplot & helper functions\nlibrary(scales)    # more helper functions\n\n# optional: sort factor levels of groups column according to highest mean\n# ...in means table\nmodel_means_cld <- model_means_cld %>% \n  mutate(group = fct_reorder(group, emmean))\n# ...in data table\nPlantGrowth <- PlantGrowth %>% \n  mutate(group = fct_relevel(group, levels(model_means_cld$group)))\n\n# plot\nggplot() +\n  # y-axis\n  scale_y_continuous(\n    name = \"Weight\",\n    limits = c(0, NA),\n    breaks = pretty_breaks(),\n    expand = expansion(mult = c(0,0.1))\n  ) +\n  # x-axis\n  scale_x_discrete(\n    name = \"Treatment\"\n  ) +\n  # general layout\n  theme_classic() +\n  theme(plot.caption = element_textbox_simple()) +\n  # bars\n  geom_bar(data = model_means_cld,\n           aes(y = emmean, x = group),\n           stat = \"identity\") +\n  # errorbars\n  geom_errorbar(data = model_means_cld,\n                aes(\n                  ymin = emmean - SE,\n                  ymax = emmean + SE,\n                  x = group\n                ),\n                width = 0.1) +\n  # letters\n  geom_text(\n    data = model_means_cld,\n    aes(\n      y = emmean + SE,\n      x = group,\n      label = str_trim(.group)\n    ),\n    hjust = 0.5,\n    vjust = -0.5\n  ) +\n  # caption\n  labs(\n    caption = \"Bars with errorbars represent (estimated marginal) means ± standard error. Means not sharing any letter are significantly different by the Tukey-test at the 5% level of significance.\"\n  )"
  },
  {
    "objectID": "summaryarticles/compactletterdisplay.html#alternative-plots",
    "href": "summaryarticles/compactletterdisplay.html#alternative-plots",
    "title": "Compact Letter Display (CLD)",
    "section": "Alternative plots",
    "text": "Alternative plots\nNote that I simply collect alternative ways of plotting adjusted mean comparisons here - this does not mean I fully grasp their concept.\nalt 1: Pairwise P-value plot {emmeans}\nThis is the Pairwise P-value plot suggested in the former NOTE we received above as an alternative. The documentation reads: Factor levels (or combinations thereof) are plotted on the vertical scale, and P values are plotted on the horizontal scale. Each P value is plotted twice – at vertical positions corresponding to the levels being compared – and connected by a line segment. Thus, it is easy to visualize which P values are small and large, and which levels are compared.\n\nClick to show/hide codepwpp(model_means) + theme_bw()\n\n\n\n\nalt 2: Lighthouse plot {easystats}\nWithin the framework of the easystats packages, the lighthouse plots came up as a more recent idea. See this issue and this and this part of the documentation for more details.\n\nClick to show/hide codelibrary(modelbased)\nlibrary(see)\nplot(estimate_contrasts(model, adjust = \"tukey\"),\n     estimate_means(model)) +\n  theme_classic()\n\n\n\n\nalt 3: The {ggbetweenstats} plot\nFinally, the ggstatsplot package’s function ggbetweenstats() aims to create graphics with details from statistical tests included in the information-rich plots themselves and would compare our groups like this:\n\nClick to show/hide codelibrary(PMCMRplus)\nlibrary(rstantools)\nlibrary(ggstatsplot)\n# \"since the confidence intervals for the effect sizes are computed using\n# bootstrapping, important to set a seed for reproducibility\"\nset.seed(42)\nggstatsplot::ggbetweenstats(\n  data = PlantGrowth,\n  x = group,\n  y = weight,\n  pairwise.comparisons = TRUE,\n  pairwise.display = \"all\",\n  p.adjust.method = \"none\"\n)"
  },
  {
    "objectID": "summaryarticles/workshopprep.html",
    "href": "summaryarticles/workshopprep.html",
    "title": "Prepare for an upcoming workshop",
    "section": "",
    "text": "Hi there! If you are reading this, you will most likely soon participate in a workshop given by me. Thank you - I am already looking forward to it! Here are some tips to help you prepare."
  },
  {
    "objectID": "summaryarticles/workshopprep.html#r-packages",
    "href": "summaryarticles/workshopprep.html#r-packages",
    "title": "Prepare for an upcoming workshop",
    "section": "R-packages",
    "text": "R-packages\nDuring the workshop you will get to know and install many additional R-packages that are not automatically installed. In most cases, you can just install them the moment they are introduced. However, if you e.g. have a slow internet connection, it may be worthwhile to install them beforehand. You can install most of the packages we need by running the following code:\n\nClick to show/hide codeif (!require(\"pacman\", quietly = TRUE))\n  install.packages(\"pacman\")\n\npacman::p_load(\n  conflicted,\n  desplot,\n  dlookr,\n  emmeans,\n  glmmTMB,\n  here,\n  janitor,\n  lme4,\n  lmerTest,\n  multcomp,\n  multcompView,\n  openxlsx,\n  scales,\n  tidyverse\n)"
  },
  {
    "objectID": "summaryarticles/workshopprep.html#having-two-screens-helps",
    "href": "summaryarticles/workshopprep.html#having-two-screens-helps",
    "title": "Prepare for an upcoming workshop",
    "section": "Having two screens helps!",
    "text": "Having two screens helps!\nDuring the workshop, I will constantly share my screen with you. Depending on whether you have multiple screens available or not, there are three main scenarios in my experience - ranked from worst to best:\n\nYou only have a single screen\nWhile this is the worst scenario, you obviously can still participate and will have no problem following me during the workshop. What may become difficult, however, is if you want to both look at my shared screen and also write your own R code simulatenously. If you only have only a single screen (that is not super wide), this means constantly switching between zoom and R. Nevertheless, there will be exercises during the workshop where everone has time to do an assignment on their own so that during those time you will definitely get some undivided R time.\nYou have a two screens, but they are not connected to the same deviceAn example for such a scenario would be having a computer with one screen and a laptop/tablet next to it. You could open R on one device and zoom on the other. This is certainly better than having only a single screen, since it is much easier to simultaneously read my and write your code. It is not optimal, however, since it does not allow for the advantages (i) and (ii) listed for scenario 3 below.\nYou have two screensHaving a computer/laptop with multiple screens connected is the optimal setup! You can easily look at both my and your R code and additionally (i) share your screen via zoom so that we can fix an issue you are having in R and (ii) copy-paste things from the zoom-chat into R."
  },
  {
    "objectID": "summaryarticles/workshopprep.html#do-i-need-to-install-zoom",
    "href": "summaryarticles/workshopprep.html#do-i-need-to-install-zoom",
    "title": "Prepare for an upcoming workshop",
    "section": "Do I need to install zoom?",
    "text": "Do I need to install zoom?\n(Obviously, this section is only relevant if the workshop will be held via zoom and not some other video communication software.)\nNo, not necessarily. It is not required to install the zoom software in order to participate in a zoom meeting, because you can also join from your browser (see details here and here). Basically, there will be a link that says “Join from your browser” and that’s it. However, be aware that there are some minor functions not available to you if you are joining from your browser."
  },
  {
    "objectID": "summaryarticles/workshopprep.html#what-else",
    "href": "summaryarticles/workshopprep.html#what-else",
    "title": "Prepare for an upcoming workshop",
    "section": "What else?",
    "text": "What else?\n\nCheck your microphoneMake sure we can hear you when asking a question.\nCheck your camera\nThis is optional of course, but I prefer participants turning their camera on as seeing your reactions improves the workshop.\n\nGet familiar with the options/functions\n\nKnow how to mute your microphone. It should be muted at all times except when you are actually talking to us.\nKnow how to use the zoom chat.\nIn zoom, know how to give a “thumbs up” - making a symbol appear on your screen."
  }
]