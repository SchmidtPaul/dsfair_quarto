[
  {
    "objectID": "ch/exan/simple/rcbd_clewerscarisbrick2001.html",
    "href": "ch/exan/simple/rcbd_clewerscarisbrick2001.html",
    "title": "One-way randomized complete block design",
    "section": "",
    "text": "# (install &) load packages\npacman::p_load(\n  conflicted,\n  desplot,\n  emmeans,\n  ggtext,\n  multcomp,\n  multcompView,\n  tidyverse)\n\n# handle function conflicts\nconflicts_prefer(dplyr::filter) \nconflicts_prefer(dplyr::select)"
  },
  {
    "objectID": "ch/exan/simple/rcbd_clewerscarisbrick2001.html#import",
    "href": "ch/exan/simple/rcbd_clewerscarisbrick2001.html#import",
    "title": "One-way randomized complete block design",
    "section": "Import",
    "text": "Import\n\n\n# data is available online:\npath &lt;- \"https://raw.githubusercontent.com/SchmidtPaul/dsfair_quarto/master/data/Clewer&Scarisbrick2001.csv\"\n\n\n\ndat &lt;- read_csv(path) # use path from above\ndat\n\n# A tibble: 12 × 5\n   block cultivar yield   row   col\n   &lt;chr&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 B1    C1         7.4     2     1\n 2 B1    C2         9.8     3     1\n 3 B1    C3         7.3     1     1\n 4 B1    C4         9.5     4     1\n 5 B2    C1         6.5     1     2\n 6 B2    C2         6.8     4     2\n 7 B2    C3         6.1     3     2\n 8 B2    C4         8       2     2\n 9 B3    C1         5.6     2     3\n10 B3    C2         6.2     1     3\n11 B3    C3         6.4     3     3\n12 B3    C4         7.4     4     3"
  },
  {
    "objectID": "ch/exan/simple/rcbd_clewerscarisbrick2001.html#format",
    "href": "ch/exan/simple/rcbd_clewerscarisbrick2001.html#format",
    "title": "One-way randomized complete block design",
    "section": "Format",
    "text": "Format\nBefore anything, the columns block and cultivar should be encoded as factors, since R by default encoded them as character.\n\ndat &lt;- dat %&gt;%\n  mutate(across(c(block, cultivar), ~ as.factor(.x)))"
  },
  {
    "objectID": "ch/exan/simple/rcbd_clewerscarisbrick2001.html#explore",
    "href": "ch/exan/simple/rcbd_clewerscarisbrick2001.html#explore",
    "title": "One-way randomized complete block design",
    "section": "Explore",
    "text": "Explore\nWe make use of dlookr::describe() to conveniently obtain descriptive summary tables. Here, we get can summarize per block and per cultivar.\n\n\n\ndat %&gt;% \n  group_by(cultivar) %&gt;% \n  dlookr::describe(yield) %&gt;% \n  select(2:sd) %&gt;%\n  arrange(desc(mean))\n\n# A tibble: 4 × 5\n  cultivar     n    na  mean    sd\n  &lt;fct&gt;    &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 C4           3     0   8.3 1.08 \n2 C2           3     0   7.6 1.93 \n3 C3           3     0   6.6 0.624\n4 C1           3     0   6.5 0.9  \n\n\n\n\n\n\ndat %&gt;% \n  group_by(block) %&gt;% \n  dlookr::describe(yield) %&gt;% \n  select(2:sd) %&gt;%\n  arrange(desc(mean))\n\n# A tibble: 3 × 5\n  block     n    na  mean    sd\n  &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 B1        4     0  8.5  1.33 \n2 B2        4     0  6.85 0.819\n3 B3        4     0  6.4  0.748\n\n\n\n\nAdditionally, we can decide to plot our data:\n\nCodeggplot(data = dat) +\n  aes(y = yield, x = cultivar, color = block) +\n  geom_point() +\n    scale_x_discrete(\n    name = \"Cultivar\"\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.1))\n  ) +\n  scale_color_discrete(\n    name = \"Block\"\n  ) +\n  theme_classic()\n\n\n\n\n\n\n\nFinally, since this is an experiment that was laid with a certain experimental design (= a randomized complete block design; RCBD) - it makes sense to also get a field plan. This can be done via desplot() from {desplot}. We can even create a second field plan that gives us a feeling for the yields per plot.\n\n\n\nCodedesplot(\n  data = dat,\n  flip = TRUE, # row 1 on top, not on bottom\n  form = cultivar ~ col + row, # fill color per cultivar       \n  out1 = block, # line between blocks                     \n  text = cultivar, # cultivar names per plot\n  cex = 1, # cultviar names: font size\n  shorten = FALSE, # cultivar names: don't abbreviate\n  main = \"Field layout\", # plot title\n  show.key = FALSE # hide legend\n  ) \n\n\n\n\n\n\n\n\n\n\n\nCodedesplot(\n  data = dat,\n  flip = TRUE, # row 1 on top, not on bottom\n  form = yield ~ col + row, # fill color according to yield      \n  out1 = block, # line between blocks                     \n  text = cultivar, # cultivar names per plot\n  cex = 1, # cultviar names: font size\n  shorten = FALSE, # cultivar names: don't abbreviate\n  main = \"Yield per plot\", # plot title\n  show.key = FALSE # hide legend\n  ) \n\n\n\n\n\n\n\n\n\nThus, C4 seems to be the most promising cultivar in terms of yield. Moreover, it can be seen that yields were generally higher in block B1 (left), compared to the other blocks."
  },
  {
    "objectID": "footer.html",
    "href": "footer.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\nThis is my footer.\n\n\n\n\n\nCitationBibTeX citation:@online{schmidt2023,\n  author = {{[}Paul Schmidt{]}(https://schmidtpaul.github.io/)},\n  date = {2023-10-01},\n  url = {https://schmidtpaul.github.io/dsfair_quarto//footer.html},\n  langid = {en}\n}\nFor attribution, please cite this work as:\n[Paul Schmidt](https://schmidtpaul.github.io/). 2023. October 1, 2023.\nhttps://schmidtpaul.github.io/dsfair_quarto//footer.html."
  },
  {
    "objectID": "ch/exan/simple/alpha_johnwilliams1995.html",
    "href": "ch/exan/simple/alpha_johnwilliams1995.html",
    "title": "One-way alpha design",
    "section": "",
    "text": "# (install &) load packages\npacman::p_load(\n  agridat,\n  conflicted,\n  desplot,\n  emmeans,\n  ggtext,\n  lme4,\n  lmerTest,\n  multcomp,\n  multcompView,\n  tidyverse)\n\n# handle function conflicts\nconflicts_prefer(dplyr::filter) \nconflicts_prefer(dplyr::select)\nconflicts_prefer(lmerTest::lmer)"
  },
  {
    "objectID": "ch/exan/simple/alpha_johnwilliams1995.html#import",
    "href": "ch/exan/simple/alpha_johnwilliams1995.html#import",
    "title": "One-way alpha design",
    "section": "Import",
    "text": "Import\nThe data is available as part of the {agridat} package and needs no further formatting:\n\ndat &lt;- as_tibble(agridat::john.alpha)\ndat\n\n# A tibble: 72 × 7\n    plot rep   block gen   yield   row   col\n   &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;\n 1     1 R1    B1    G11    4.12     1     1\n 2     2 R1    B1    G04    4.45     2     1\n 3     3 R1    B1    G05    5.88     3     1\n 4     4 R1    B1    G22    4.58     4     1\n 5     5 R1    B2    G21    4.65     5     1\n 6     6 R1    B2    G10    4.17     6     1\n 7     7 R1    B2    G20    4.01     7     1\n 8     8 R1    B2    G02    4.34     8     1\n 9     9 R1    B3    G23    4.23     9     1\n10    10 R1    B3    G14    4.76    10     1\n# ℹ 62 more rows"
  },
  {
    "objectID": "ch/exan/simple/alpha_johnwilliams1995.html#explore",
    "href": "ch/exan/simple/alpha_johnwilliams1995.html#explore",
    "title": "One-way alpha design",
    "section": "Explore",
    "text": "Explore\nWe make use of dlookr::describe() to conveniently obtain descriptive summary tables. Here, we get can summarize per block and per cultivar.\n\n\n\ndat %&gt;% \n  group_by(gen) %&gt;% \n  dlookr::describe(yield) %&gt;% \n  select(2:n, mean, sd) %&gt;%\n  arrange(desc(n), desc(mean)) %&gt;% \n  print(n = Inf)\n\n# A tibble: 24 × 4\n   gen       n  mean     sd\n   &lt;fct&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 G01       3  5.16 0.534 \n 2 G05       3  5.06 0.841 \n 3 G12       3  4.91 0.641 \n 4 G15       3  4.89 0.207 \n 5 G19       3  4.87 0.398 \n 6 G13       3  4.83 0.619 \n 7 G21       3  4.82 0.503 \n 8 G17       3  4.73 0.379 \n 9 G16       3  4.73 0.502 \n10 G06       3  4.71 0.464 \n11 G22       3  4.64 0.432 \n12 G14       3  4.56 0.186 \n13 G02       3  4.51 0.574 \n14 G18       3  4.44 0.587 \n15 G04       3  4.40 0.0433\n16 G10       3  4.39 0.450 \n17 G11       3  4.38 0.641 \n18 G08       3  4.32 0.584 \n19 G24       3  4.14 0.726 \n20 G23       3  4.14 0.232 \n21 G07       3  4.13 0.510 \n22 G20       3  3.78 0.209 \n23 G09       3  3.61 0.606 \n24 G03       3  3.34 0.456 \n\n\n\n\n\n\ndat %&gt;% \n  group_by(rep, block) %&gt;% \n  dlookr::describe(yield) %&gt;% \n  select(2:n, mean, sd) %&gt;%\n  arrange(desc(mean)) %&gt;% \n  print(n = Inf)\n\n# A tibble: 18 × 5\n   rep   block     n  mean     sd\n   &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n 1 R2    B3        4  5.22 0.149 \n 2 R2    B5        4  5.21 0.185 \n 3 R2    B6        4  5.11 0.323 \n 4 R2    B4        4  5.01 0.587 \n 5 R1    B5        4  4.79 0.450 \n 6 R1    B1        4  4.75 0.772 \n 7 R1    B6        4  4.58 0.819 \n 8 R3    B1        4  4.38 0.324 \n 9 R1    B3        4  4.36 0.337 \n10 R1    B4        4  4.33 0.727 \n11 R3    B3        4  4.30 0.0710\n12 R1    B2        4  4.29 0.273 \n13 R2    B2        4  4.23 0.504 \n14 R3    B4        4  4.22 0.375 \n15 R3    B5        4  4.15 0.398 \n16 R2    B1        4  4.12 0.411 \n17 R3    B2        4  3.96 0.631 \n18 R3    B6        4  3.61 0.542 \n\n\n\n\nAdditionally, we can decide to plot our data:\n\nCode# sort genotypes by mean yield\ngen_order &lt;- dat %&gt;% \n  group_by(gen) %&gt;% \n  summarise(mean = mean(yield)) %&gt;% \n  arrange(mean) %&gt;% \n  pull(gen) %&gt;% \n  as.character()\n\nggplot(data = dat) +\n  aes(\n    y = yield,\n    x = gen,\n    shape = rep\n  ) +\n  geom_line(\n    aes(group = gen),\n    color = \"darkgrey\"\n  ) +\n  geom_point() +\n  scale_x_discrete(\n    name = \"Genotype\",\n    limits = gen_order\n  ) +\n  scale_y_continuous(\n    name = \"Yield\",\n    limits = c(0, NA),\n    expand = expansion(mult = c(0, 0.05))\n  ) +\n  scale_shape_discrete(\n    name = \"Block\"\n  ) +\n  guides(shape = guide_legend(nrow = 1)) +\n  theme_classic() +\n  theme(\n    legend.position = \"top\", \n    axis.text.x = element_text(angle = 90, vjust = 0.5)\n  )\n\n\n\n\n\n\n\nFinally, since this is an experiment that was laid with a certain experimental design (= a non-resolvable augmented design) - it makes sense to also get a field plan. This can be done via desplot() from {desplot}.\n\nCodedesplot(\n  data = dat, \n  flip = TRUE, # row 1 on top, not on bottom\n  form = gen ~ row + col | rep, # fill color per genotype, headers per replicate\n  out1 = block, # lines between incomplete blocks\n  out1.gpar = list(col = \"black\", lwd = 1, lty = \"dashed\"), # line type\n  main = \"Field layout\", # title\n  key.cex = 0.6,\n  layout = c(3, 1) # force all reps drawn in one row\n)"
  },
  {
    "objectID": "ch/exan/simple/alpha_johnwilliams1995.html#variance-components",
    "href": "ch/exan/simple/alpha_johnwilliams1995.html#variance-components",
    "title": "One-way alpha design",
    "section": "Variance components",
    "text": "Variance components\nTo extract variance components from our models, we unfortunately need different functions per model since only of of them is a mixed model and we used different functions to fit them.\n\n\n\n# Residual Variance\nsummary(mod_fb)$sigma^2\n\n[1] 0.08346307\n\n\n\n\n\n\n# Both Variance Components\nas_tibble(VarCorr(mod_rb))\n\n# A tibble: 2 × 5\n  grp       var1        var2    vcov sdcor\n  &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 rep:block (Intercept) &lt;NA&gt;  0.0619 0.249\n2 Residual  &lt;NA&gt;        &lt;NA&gt;  0.0852 0.292"
  },
  {
    "objectID": "ch/exan/simple/alpha_johnwilliams1995.html#efficiency",
    "href": "ch/exan/simple/alpha_johnwilliams1995.html#efficiency",
    "title": "One-way alpha design",
    "section": "Efficiency",
    "text": "Efficiency\nThe efficiency of a resolvable design can be calculated as its mean s.e.d. compared to the (mean1) s.e.d. of the analogous RCBD, i.e. leaving out the incomplete block effects within the replicates. Above, we have already calculated the mean s.e.d. of our resolvable design so we can square it and get avg_sed_mod_rb^2 which is 0.07292. Accordingly, we can fit a model leaving out the incomplete block effects and get the s.e.d. just like before and also square it:\n\navg_sed_mod_RCBD &lt;- lm(yield ~ gen + rep, data = dat) %&gt;% \n  emmeans(pairwise ~ \"gen\",\n          adjust = \"none\",\n          lmer.df = \"kenward-roger\") %&gt;%\n  pluck(\"contrasts\") %&gt;% # extract diffs\n  as_tibble() %&gt;% # format to table\n  pull(\"SE\") %&gt;% # extract s.e.d. column\n  mean()\n\navg_sed_mod_RCBD^2\n\n[1] 0.08972397\n\n\nFinally, the efficiency of this resolvable is then\n\navg_sed_mod_RCBD^2 / avg_sed_mod_rb^2\n\n[1] 1.230428\n\n\nmeaning that the resolvable design is indeed more efficient since the efficiency is &gt; 1."
  },
  {
    "objectID": "ch/exan/simple/alpha_johnwilliams1995.html#footnotes",
    "href": "ch/exan/simple/alpha_johnwilliams1995.html#footnotes",
    "title": "One-way alpha design",
    "section": "Footnotes",
    "text": "Footnotes\n\nIn this scenario, all s.e.d. of the RCBD model would be identical so we don’t really need to get the average, but could instead argue that there is only one constant s.e.d.↩︎"
  },
  {
    "objectID": "ch/rbasics/tidyverse.html",
    "href": "ch/rbasics/tidyverse.html",
    "title": "The tidyverse",
    "section": "",
    "text": "When using R, you will sooner or later hear about the {tidyverse}. The tidyverse is a collection of R packages that “share an underlying design philosophy, grammar, and data structures” of tidy data. The individual tidyverse packages comprise some of the most downloaded R packages.\nInstall the complete tidyverse with:\ninstall.packages(\"tidyverse\")\n# or\npacman::p_load(\"tidyverse\")\nI did not use the tidyverse packages in my first years using R, but I wish I did. While you can often reach your goal with or without using the tidyverse packages, I personally prefer using them. Thus, they are used extensively throughout the chapters of this website.\nDuring the next sections I will try to explain how to use some of these packages and sometimes compare them to the Base R (= non-tidyverse) alternative."
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#data.frame",
    "href": "ch/rbasics/tidyverse.html#data.frame",
    "title": "The tidyverse",
    "section": "data.frame",
    "text": "data.frame\nBase R has a standard format for data tables called data.frame. Here is an example table that is an R built-in, just like pi is - it is called PlantGrowth:\n\nPlantGrowth\n\n   weight group\n1    4.17  ctrl\n2    5.58  ctrl\n3    5.18  ctrl\n4    6.11  ctrl\n5    4.50  ctrl\n6    4.61  ctrl\n7    5.17  ctrl\n8    4.53  ctrl\n9    5.33  ctrl\n10   5.14  ctrl\n11   4.81  trt1\n12   4.17  trt1\n13   4.41  trt1\n14   3.59  trt1\n15   5.87  trt1\n16   3.83  trt1\n17   6.03  trt1\n18   4.89  trt1\n19   4.32  trt1\n20   4.69  trt1\n21   6.31  trt2\n22   5.12  trt2\n23   5.54  trt2\n24   5.50  trt2\n25   5.37  trt2\n26   5.29  trt2\n27   4.92  trt2\n28   6.15  trt2\n29   5.80  trt2\n30   5.26  trt2\n\n\nLet us create a copy of this table called df (dataframe) and then use some helpful functions to get a first impression of this data:\n\ndf &lt;- PlantGrowth\nstr(df)\n\n'data.frame':   30 obs. of  2 variables:\n $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nsummary(df)\n\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n\n\nWe can see that this dataset has 30 observations (=rows) and 2 variables (=columns) and is of the type “data.frame”. Furthermore, the first variable is called weight and contains numeric values for which we get some measures of central tendency like the minimum, maximum, mean and median. The second variable is called group and is of the type factor containing a total of three different levels, which each appear 10 times.\nIf you want to extract/use values of only one column of such a data.frame, you write the name of the data.frame, then a $ and finally the name of the respective column. It returns the values of that column as a vector:\n\ndf$weight\n\n [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n[16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n\ndf$group\n\n [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n[16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\nLevels: ctrl trt1 trt2"
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#tibble",
    "href": "ch/rbasics/tidyverse.html#tibble",
    "title": "The tidyverse",
    "section": "tibble",
    "text": "tibble\nOne major aspect of the tidyverse is formatting tables as tibble instead of data.frame. A tibble “is a modern reimagining of the data.frame, keeping what time has proven to be effective, and throwing out what is not.” It is super simple to convert a data.frame into a tibble, but you must have the tidyverse R package {tibble} installed and loaded - which it is if you are loading the entire {tidyverse}. Let us convert our df into a tibble and call it tbl:\n\npacman::p_load(tidyverse)\ntbl &lt;- as_tibble(df)\ntbl\n\n# A tibble: 30 × 2\n   weight group\n    &lt;dbl&gt; &lt;fct&gt;\n 1   4.17 ctrl \n 2   5.58 ctrl \n 3   5.18 ctrl \n 4   6.11 ctrl \n 5   4.5  ctrl \n 6   4.61 ctrl \n 7   5.17 ctrl \n 8   4.53 ctrl \n 9   5.33 ctrl \n10   5.14 ctrl \n# ℹ 20 more rows\n\n\nOf course, the data itself does not change - only its format and the way it is displayed to us in R. If you compare the output we get from printing tbl here to that of printing df above, I would like to point out some things I find extremely convenient for tibbles:\n\nThere is an extra first line telling us about the number of rows and columns.\nThere is an extra line below the column names telling us about the data type of each column.\nOnly the first ten rows of data are printed and a “… with 20 more rows” is added below.\nIt can’t be seen here, but this would analogously happen if there were too many columns.\nIt can’t be seen here, but missing values NA and negative numbers are printed in red.\n\nFinally, note that in its heart, a tibble is still a data.frame and in most cases you can do everything with a tibble that you can do with a data.frame:\n\n\n\nclass(tbl)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nstr(tbl)\n\ntibble [30 × 2] (S3: tbl_df/tbl/data.frame)\n $ weight: num [1:30] 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nsummary(tbl)\n\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n\ntbl$weight\n\n [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n[16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n\ntbl$group\n\n [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n[16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\nLevels: ctrl trt1 trt2\n\n\n\n\n\n\nclass(df)\n\n[1] \"data.frame\"\n\nstr(df)\n\n'data.frame':   30 obs. of  2 variables:\n $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nsummary(df)\n\n     weight       group   \n Min.   :3.590   ctrl:10  \n 1st Qu.:4.550   trt1:10  \n Median :5.155   trt2:10  \n Mean   :5.073            \n 3rd Qu.:5.530            \n Max.   :6.310            \n\ndf$weight\n\n [1] 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 4.81 4.17 4.41 3.59 5.87\n[16] 3.83 6.03 4.89 4.32 4.69 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26\n\ndf$group\n\n [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1\n[16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2\nLevels: ctrl trt1 trt2\n\n\n\n\nTherefore, I almost always format my datasets as tibbles."
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#no-pipe---intermediate-steps",
    "href": "ch/rbasics/tidyverse.html#no-pipe---intermediate-steps",
    "title": "The tidyverse",
    "section": "No pipe - intermediate steps",
    "text": "No pipe - intermediate steps\nUsing one function at a time and saving the output in the variables a - d, we can do this:\n\na &lt;- filter(PlantGrowth, group == \"ctrl\")\nb &lt;- pull(a, weight) # same as: b &lt;- a$weight\nc &lt;- sqrt(b)\nd &lt;- round(c, digits = 1)\nsort(d)\n\n [1] 2.0 2.1 2.1 2.1 2.3 2.3 2.3 2.3 2.4 2.5"
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#no-pipe---nesting-functions",
    "href": "ch/rbasics/tidyverse.html#no-pipe---nesting-functions",
    "title": "The tidyverse",
    "section": "No pipe - nesting functions",
    "text": "No pipe - nesting functions\nJust like in MS Excel, it is possible to write functions inside of functions so that we can do this:\n\nsort(round(sqrt(pull(filter(PlantGrowth, group == \"ctrl\"), weight)), digits = 1))\n\n [1] 2.0 2.1 2.1 2.1 2.3 2.3 2.3 2.3 2.4 2.5"
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#pipe",
    "href": "ch/rbasics/tidyverse.html#pipe",
    "title": "The tidyverse",
    "section": "Pipe!",
    "text": "Pipe!\nThis approach (i) allows you to write functions from left to right / top to bottom and thus in the order they are executed and the way you think about them and (ii) does not create extra variables for intermediate steps:\n\nPlantGrowth %&gt;% \n  filter(group == \"ctrl\") %&gt;% \n  pull(weight) %&gt;% \n  sqrt() %&gt;% \n  round(digits = 1) %&gt;% \n  sort()\n\n [1] 2.0 2.1 2.1 2.1 2.3 2.3 2.3 2.3 2.4 2.5\n\n\nYou can think about it like this: Something (in this case the PlantGrowth data.frame) goes into the pipe and is directed to the next function filter(). By default, this function takes what came out of the previous pipe and puts it as its first argument. This happens with every pipe. You’ll notice that all the functions who required two arguments above, now only need one argument, i.e. the additional argument, because the main argument stating which data is to be used is by default simply what came out of the previous pipe. Accordingly, the functions sqrt() and sort() appear empty here, because they only need one piece of information and that is which data they should work with. Finally note that you can easily highlight only some of the lines up until one of the pipes to see the intermediate results.\n\n\n\n\n\n\nNote\n\n\n\nThe keyboard shortcut for writing %&gt;% in RStudio is CTRL+SHIFT+M. Keyboard shortcuts can be customized in RStudio as described here."
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#mutate",
    "href": "ch/rbasics/tidyverse.html#mutate",
    "title": "The tidyverse",
    "section": "mutate()",
    "text": "mutate()\nThis function is useful whenever you want to change existing columns or add new columns to your table. To keep the following examples short and simple, let’s create tbl2 as only the first six rows of tbl via the head() function:\n\ntbl2 &lt;- head(tbl)\ntbl2\n\n# A tibble: 6 × 2\n  weight group\n   &lt;dbl&gt; &lt;fct&gt;\n1   4.17 ctrl \n2   5.58 ctrl \n3   5.18 ctrl \n4   6.11 ctrl \n5   4.5  ctrl \n6   4.61 ctrl \n\n\nLet’s start by adding 2 to the weight in our data. Below, we do this two different ways: by adding a column named new to the dataset (left) and by replacing/overwriting the original weight column (right):\n\n\n\ntbl2 %&gt;% \n  mutate(new = weight + 2)\n\n# A tibble: 6 × 3\n  weight group   new\n   &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt;\n1   4.17 ctrl   6.17\n2   5.58 ctrl   7.58\n3   5.18 ctrl   7.18\n4   6.11 ctrl   8.11\n5   4.5  ctrl   6.5 \n6   4.61 ctrl   6.61\n\n\n\n\n\n\ntbl2 %&gt;% \n  mutate(weight = weight + 2)\n\n# A tibble: 6 × 2\n  weight group\n   &lt;dbl&gt; &lt;fct&gt;\n1   6.17 ctrl \n2   7.58 ctrl \n3   7.18 ctrl \n4   8.11 ctrl \n5   6.5  ctrl \n6   6.61 ctrl \n\n\n\n\nWe can also create multiple columns at once (left) and make the values of the new column dynamically depend on the other columns via case_when() (right):\n\n\n\ntbl2 %&gt;%\n  mutate(\n    `Name with Space` = \"Hello!\",\n    number10 = 10\n  )\n\n# A tibble: 6 × 4\n  weight group `Name with Space` number10\n   &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt;                &lt;dbl&gt;\n1   4.17 ctrl  Hello!                  10\n2   5.58 ctrl  Hello!                  10\n3   5.18 ctrl  Hello!                  10\n4   6.11 ctrl  Hello!                  10\n5   4.5  ctrl  Hello!                  10\n6   4.61 ctrl  Hello!                  10\n\n\n\n\n\n\ntbl2 %&gt;% \n  mutate(size = case_when(\n    weight &gt; 5.5 ~ \"large\",\n    weight &lt; 4.5 ~ \"small\",\n    TRUE ~ \"normal\" # everything else\n  ))\n\n# A tibble: 6 × 3\n  weight group size  \n   &lt;dbl&gt; &lt;fct&gt; &lt;chr&gt; \n1   4.17 ctrl  small \n2   5.58 ctrl  large \n3   5.18 ctrl  normal\n4   6.11 ctrl  large \n5   4.5  ctrl  normal\n6   4.61 ctrl  normal\n\n\n\n\nFinally, we can efficiently apply the same function to multiple columns at once via across(). We can select the columns e.g. manually via their names in a vector (left) or via a function such as is.numeric (right):\n\n\n\ntbl2 %&gt;%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %&gt;%\n  mutate(\n    across(c(v1, v2), ~ .x + 20)\n    )\n\n# A tibble: 6 × 5\n  weight group    v1    v2    v3\n   &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1   4.17 ctrl     21    22     3\n2   5.58 ctrl     21    22     3\n3   5.18 ctrl     21    22     3\n4   6.11 ctrl     21    22     3\n5   4.5  ctrl     21    22     3\n6   4.61 ctrl     21    22     3\n\n\n\n\n\n\ntbl2 %&gt;%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %&gt;%\n  mutate(\n    across(where(is.numeric), ~ .x + 20)\n    )\n\n# A tibble: 6 × 5\n  weight group    v1    v2    v3\n   &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1   24.2 ctrl     21    22    23\n2   25.6 ctrl     21    22    23\n3   25.2 ctrl     21    22    23\n4   26.1 ctrl     21    22    23\n5   24.5 ctrl     21    22    23\n6   24.6 ctrl     21    22    23\n\n\n\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\n\n\n\n5.5 Add new variables with mutate() in R for data science (Wickham and Grolemund 2017)\n\nCreate, modify, and delete columns with mutate()\nA general vectorised if with case_when()\nApply a function (or functions) across multiple columns with across()"
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#select",
    "href": "ch/rbasics/tidyverse.html#select",
    "title": "The tidyverse",
    "section": "select()",
    "text": "select()\nThis function is useful whenever you want to select a subset of columns or change the order of columns. To provide better examples, let’s first create a table tbl3 with a few more columns:\n\ntbl3 &lt;- tbl2 %&gt;% \n  mutate(var1 = 1, var2 = 2, var3 = \"text\", var4 = \"word\")\n\ntbl3\n\n# A tibble: 6 × 6\n  weight group  var1  var2 var3  var4 \n   &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1   4.17 ctrl      1     2 text  word \n2   5.58 ctrl      1     2 text  word \n3   5.18 ctrl      1     2 text  word \n4   6.11 ctrl      1     2 text  word \n5   4.5  ctrl      1     2 text  word \n6   4.61 ctrl      1     2 text  word \n\n\nWe can now select individual columns manually by giving all names (left) and even select all columns from:to by writing a colon between them (right):\n\n\n\ntbl3 %&gt;% \n  select(group, var1, var4)\n\n# A tibble: 6 × 3\n  group  var1 var4 \n  &lt;fct&gt; &lt;dbl&gt; &lt;chr&gt;\n1 ctrl      1 word \n2 ctrl      1 word \n3 ctrl      1 word \n4 ctrl      1 word \n5 ctrl      1 word \n6 ctrl      1 word \n\n\n\n\n\n\ntbl3 %&gt;% \n  select(group, var1:var4)\n\n# A tibble: 6 × 5\n  group  var1  var2 var3  var4 \n  &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1 ctrl      1     2 text  word \n2 ctrl      1     2 text  word \n3 ctrl      1     2 text  word \n4 ctrl      1     2 text  word \n5 ctrl      1     2 text  word \n6 ctrl      1     2 text  word \n\n\n\n\nWe can also delete specific columns by putting a - in fornt of their name or use functions like starts_with(), ends_with(), contains(), matches() and num_range() to select all columns based on (parts of) their name:\n\n\n\ntbl3 %&gt;% \n  select(-group)\n\n# A tibble: 6 × 5\n  weight  var1  var2 var3  var4 \n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1   4.17     1     2 text  word \n2   5.58     1     2 text  word \n3   5.18     1     2 text  word \n4   6.11     1     2 text  word \n5   4.5      1     2 text  word \n6   4.61     1     2 text  word \n\n\n\n\n\n\ntbl3 %&gt;% \n  select(contains(\"r\"))\n\n# A tibble: 6 × 5\n  group  var1  var2 var3  var4 \n  &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1 ctrl      1     2 text  word \n2 ctrl      1     2 text  word \n3 ctrl      1     2 text  word \n4 ctrl      1     2 text  word \n5 ctrl      1     2 text  word \n6 ctrl      1     2 text  word \n\n\n\n\nFinally, we can select based on a function like is.numeric via where() (left) or simply rearrange while keeping all columns by using everything() (right)\n\n\n\ntbl3 %&gt;% \n  select(where(is.numeric))\n\n# A tibble: 6 × 3\n  weight  var1  var2\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1   4.17     1     2\n2   5.58     1     2\n3   5.18     1     2\n4   6.11     1     2\n5   4.5      1     2\n6   4.61     1     2\n\n\n\n\n\n\ntbl3 %&gt;% \n  select(var1, everything())\n\n# A tibble: 6 × 6\n   var1 weight group  var2 var3  var4 \n  &lt;dbl&gt;  &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n1     1   4.17 ctrl      2 text  word \n2     1   5.58 ctrl      2 text  word \n3     1   5.18 ctrl      2 text  word \n4     1   6.11 ctrl      2 text  word \n5     1   4.5  ctrl      2 text  word \n6     1   4.61 ctrl      2 text  word \n\n\n\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\n\n\n\n5.4 Select columns with select() in R for data science (Wickham and Grolemund 2017)\n\nSubset columns using their names and types with select()\nSelect variables that match a pattern with starts_with() etc.\nSelect variables with a function with where()"
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#filter",
    "href": "ch/rbasics/tidyverse.html#filter",
    "title": "The tidyverse",
    "section": "filter()",
    "text": "filter()\nThis function is useful whenever you want to subset rows based on their values. Note that for the examples here, we use the original tbl with 30 observations.\nLet’s immediately filter for two conditions: Observations that belong to group trt2 and (&) are larger than 6 (left); Observations that are larger than 6 or (|) smaller than 4 (right):\n\n\n\ntbl %&gt;% \n  filter(weight &gt; 6 & group == \"trt2\")\n\n# A tibble: 2 × 2\n  weight group\n   &lt;dbl&gt; &lt;fct&gt;\n1   6.31 trt2 \n2   6.15 trt2 \n\n\n\n\n\n\ntbl %&gt;% \n  filter(weight &gt; 6 | weight &lt; 4)\n\n# A tibble: 6 × 2\n  weight group\n   &lt;dbl&gt; &lt;fct&gt;\n1   6.11 ctrl \n2   3.59 trt1 \n3   3.83 trt1 \n4   6.03 trt1 \n5   6.31 trt2 \n6   6.15 trt2 \n\n\n\n\nInstead of writing a lot of conditions separated by |, it is often more efficient to use %in%:\n\n\n\ntbl %&gt;% \n  filter(group == \"trt1\" | group == \"trt2\")\n\n# A tibble: 20 × 2\n   weight group\n    &lt;dbl&gt; &lt;fct&gt;\n 1   4.81 trt1 \n 2   4.17 trt1 \n 3   4.41 trt1 \n 4   3.59 trt1 \n 5   5.87 trt1 \n 6   3.83 trt1 \n 7   6.03 trt1 \n 8   4.89 trt1 \n 9   4.32 trt1 \n10   4.69 trt1 \n11   6.31 trt2 \n12   5.12 trt2 \n13   5.54 trt2 \n14   5.5  trt2 \n15   5.37 trt2 \n16   5.29 trt2 \n17   4.92 trt2 \n18   6.15 trt2 \n19   5.8  trt2 \n20   5.26 trt2 \n\n\n\n\n\n\ntbl %&gt;% \n  filter(group %in% c(\"trt1\", \"trt2\"))\n\n# A tibble: 20 × 2\n   weight group\n    &lt;dbl&gt; &lt;fct&gt;\n 1   4.81 trt1 \n 2   4.17 trt1 \n 3   4.41 trt1 \n 4   3.59 trt1 \n 5   5.87 trt1 \n 6   3.83 trt1 \n 7   6.03 trt1 \n 8   4.89 trt1 \n 9   4.32 trt1 \n10   4.69 trt1 \n11   6.31 trt2 \n12   5.12 trt2 \n13   5.54 trt2 \n14   5.5  trt2 \n15   5.37 trt2 \n16   5.29 trt2 \n17   4.92 trt2 \n18   6.15 trt2 \n19   5.8  trt2 \n20   5.26 trt2 \n\n\n\n\nWe can also filter for values that are not of the ctrl group (left) or that are larger than the mean weight (right):\n\n\n\ntbl %&gt;% \n  filter(group != \"ctrl\")\n\n# A tibble: 20 × 2\n   weight group\n    &lt;dbl&gt; &lt;fct&gt;\n 1   4.81 trt1 \n 2   4.17 trt1 \n 3   4.41 trt1 \n 4   3.59 trt1 \n 5   5.87 trt1 \n 6   3.83 trt1 \n 7   6.03 trt1 \n 8   4.89 trt1 \n 9   4.32 trt1 \n10   4.69 trt1 \n11   6.31 trt2 \n12   5.12 trt2 \n13   5.54 trt2 \n14   5.5  trt2 \n15   5.37 trt2 \n16   5.29 trt2 \n17   4.92 trt2 \n18   6.15 trt2 \n19   5.8  trt2 \n20   5.26 trt2 \n\n\n\n\n\n\ntbl %&gt;% \n  filter(weight &gt; mean(weight))\n\n# A tibble: 17 × 2\n   weight group\n    &lt;dbl&gt; &lt;fct&gt;\n 1   5.58 ctrl \n 2   5.18 ctrl \n 3   6.11 ctrl \n 4   5.17 ctrl \n 5   5.33 ctrl \n 6   5.14 ctrl \n 7   5.87 trt1 \n 8   6.03 trt1 \n 9   6.31 trt2 \n10   5.12 trt2 \n11   5.54 trt2 \n12   5.5  trt2 \n13   5.37 trt2 \n14   5.29 trt2 \n15   6.15 trt2 \n16   5.8  trt2 \n17   5.26 trt2 \n\n\n\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\n\n\n\n5.2 Filter rows with filter() in R for data science (Wickham and Grolemund 2017)\n\nSubset rows using column values with filter()"
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#arrange",
    "href": "ch/rbasics/tidyverse.html#arrange",
    "title": "The tidyverse",
    "section": "arrange()",
    "text": "arrange()\nThis function is useful whenever you want to sort rows based on their values. We’ll once more create a new version of our original dataset to best show what this function can do:\n\ntbl4 &lt;- tbl %&gt;%\n  slice(1:3, 11:13, 21:23) \n# this keeps only rows 1,2,3,11,12,13,21,22,23\n\nWe can arrange rows via writing the column name (or column index/number). Note that by default values are sorted in ascending order and strings are sorted alphabetically, but this can be reversed by using desc():\n\n\n\ntbl4 %&gt;% \n  arrange(weight)\n\n# A tibble: 9 × 2\n  weight group\n   &lt;dbl&gt; &lt;fct&gt;\n1   4.17 ctrl \n2   4.17 trt1 \n3   4.41 trt1 \n4   4.81 trt1 \n5   5.12 trt2 \n6   5.18 ctrl \n7   5.54 trt2 \n8   5.58 ctrl \n9   6.31 trt2 \n\n\n\n\n\n\ntbl4 %&gt;% \n  arrange(desc(weight))\n\n# A tibble: 9 × 2\n  weight group\n   &lt;dbl&gt; &lt;fct&gt;\n1   6.31 trt2 \n2   5.58 ctrl \n3   5.54 trt2 \n4   5.18 ctrl \n5   5.12 trt2 \n6   4.81 trt1 \n7   4.41 trt1 \n8   4.17 ctrl \n9   4.17 trt1 \n\n\n\n\nYou can also sort via multiple columns and you can provide a custom sorting order in a vector:\n\n\n\ntbl4 %&gt;% \n  arrange(group, weight)\n\n# A tibble: 9 × 2\n  weight group\n   &lt;dbl&gt; &lt;fct&gt;\n1   4.17 ctrl \n2   5.18 ctrl \n3   5.58 ctrl \n4   4.17 trt1 \n5   4.41 trt1 \n6   4.81 trt1 \n7   5.12 trt2 \n8   5.54 trt2 \n9   6.31 trt2 \n\n\n\n\n\n\nmyorder &lt;- c(\"trt1\", \"ctrl\", \"trt2\")\n\ntbl4 %&gt;% \n  arrange(\n    match(group, myorder), \n    weight\n  )\n\n# A tibble: 9 × 2\n  weight group\n   &lt;dbl&gt; &lt;fct&gt;\n1   4.17 trt1 \n2   4.41 trt1 \n3   4.81 trt1 \n4   4.17 ctrl \n5   5.18 ctrl \n6   5.58 ctrl \n7   5.12 trt2 \n8   5.54 trt2 \n9   6.31 trt2 \n\n\n\n\nNote that NA (= missing values) are always sorted to the end3, even when using desc().\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\n\n\n\n5.3 Arrange rows with arrange() in R for data science (Wickham and Grolemund 2017)\n\nArrange rows by column values with arrange()\nHow to have NA’s displayed first using arrange()"
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#summarise",
    "href": "ch/rbasics/tidyverse.html#summarise",
    "title": "The tidyverse",
    "section": "summarise()",
    "text": "summarise()\nThis function can be useful whenever you want to summarise data. Yet, it is not very useful (left) unless it is paired with group_by() (right).\n\n\n\ntbl %&gt;% \n  # no group_by \n  summarise(my_mean = mean(weight))\n\n# A tibble: 1 × 1\n  my_mean\n    &lt;dbl&gt;\n1    5.07\n\n\n\n\n\n\ntbl %&gt;% \n  group_by(group) %&gt;% \n  summarise(my_mean = mean(weight))\n\n# A tibble: 3 × 2\n  group my_mean\n  &lt;fct&gt;   &lt;dbl&gt;\n1 ctrl     5.03\n2 trt1     4.66\n3 trt2     5.53\n\n\n\n\nYou can create multiple summary output columns (left) and have multiple grouping columns (right):\n\n\n\ntbl %&gt;% \n  group_by(group) %&gt;% \n  summarise(\n    Mean = mean(weight),\n    StdDev = sd(weight),\n    Min = min(weight),\n    Median = median(weight),\n    Max = max(weight),\n    n_Obs = n(),\n  )\n\n# A tibble: 3 × 7\n  group  Mean StdDev   Min Median   Max n_Obs\n  &lt;fct&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n1 ctrl   5.03  0.583  4.17   5.15  6.11    10\n2 trt1   4.66  0.794  3.59   4.55  6.03    10\n3 trt2   5.53  0.443  4.92   5.44  6.31    10\n\n\n\n\n\n\ntbl %&gt;% \n  mutate(larger5 = case_when(\n    weight &gt; 5 ~ \"yes\",\n    weight &lt; 5 ~ \"no\"\n  )) %&gt;% \n  group_by(group, larger5) %&gt;% \n  summarise(\n    n_Obs = n(),\n    Mean = mean(weight)\n  )\n\n# A tibble: 6 × 4\n# Groups:   group [3]\n  group larger5 n_Obs  Mean\n  &lt;fct&gt; &lt;chr&gt;   &lt;int&gt; &lt;dbl&gt;\n1 ctrl  no          4  4.45\n2 ctrl  yes         6  5.42\n3 trt1  no          8  4.34\n4 trt1  yes         2  5.95\n5 trt2  no          1  4.92\n6 trt2  yes         9  5.59\n\n\n\n\nJust like with mutate(), we can make use of across() to deal with multiple columns:\n\n\n\ntbl %&gt;%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %&gt;%\n  group_by(group) %&gt;%\n  summarise(across(\n    where(is.numeric), \n    ~ mean(.x)\n    ))\n\n# A tibble: 3 × 5\n  group weight    v1    v2    v3\n  &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 ctrl    5.03     1     2     3\n2 trt1    4.66     1     2     3\n3 trt2    5.53     1     2     3\n\n\n\n\n\n\ntbl %&gt;%\n  mutate(v1 = 1, v2 = 2, v3 = 3) %&gt;%\n  group_by(group) %&gt;%\n  summarise(across(\n    c(weight, v3),\n    list(\n    Min = ~ min(.x),\n    Max = ~ max(.x)\n    )\n  ))\n\n# A tibble: 3 × 5\n  group weight_Min weight_Max v3_Min v3_Max\n  &lt;fct&gt;      &lt;dbl&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n1 ctrl        4.17       6.11      3      3\n2 trt1        3.59       6.03      3      3\n3 trt2        4.92       6.31      3      3\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nOnce you used group_by() on a table, it stays grouped unless you use ungroup() on it afterwards. This was not relevant in the examples above, but you must be aware of this if you are using the grouped (summary) results for further steps, since this can lead to unexpected results. You can find an example and further resources on such unintended outcomes here.\n\n\n\n\n\n\n\n\nAdditional Resources\n\n\n\n\n\n\n\n5.6 Grouped summaries with summarise() in R for data science (Wickham and Grolemund 2017)\n\nSummarise each group to fewer rows with summarise()\nGroup by one or more variables with group_by()"
  },
  {
    "objectID": "ch/rbasics/tidyverse.html#footnotes",
    "href": "ch/rbasics/tidyverse.html#footnotes",
    "title": "The tidyverse",
    "section": "Footnotes",
    "text": "Footnotes\n\nBut it was not the first package to use it. This blog post has a nice summary of the history of the pipe operator in R.↩︎\nNote that there are some differences between %&gt;% and |&gt; - find more about it e.g. here, here or here.↩︎\nSee the additional resources below if you want it differently.↩︎\nIt does not make a difference here, whether we put x = chr or x = fct in the ggplot statement.↩︎\nYes, the mean in this example is not really a mean, since there is only one number per group.↩︎\nNote that while I create two vectors in this example, this will work just as well with columns of a table via `table %&gt;% mutate(new = stringrfunction(old))`↩︎"
  },
  {
    "objectID": "ch/rbasics/firststeps.html",
    "href": "ch/rbasics/firststeps.html",
    "title": "First steps in R",
    "section": "",
    "text": "This chapter is mostly aimed at people who are very new to R. However, people who do know R may still find useful insights from the sections where I emphasize how I use R.\nFurthermore, this tutorial teaches R the way I use it, which means you can do (and may have done) almost everything I do here with other code/functions/approaches. “The way I use it” mostly refers to me using the {tidyverse}, which “is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures” and has become quite popular over the last years. Here is a direct comparison of how to do things in R with base R and via the tidyverse."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#base-r",
    "href": "ch/rbasics/firststeps.html#base-r",
    "title": "First steps in R",
    "section": "base R",
    "text": "base R\nAfter installing R there are many functions etc. you can use right away - which is what we did above. For example, when running ?mean, the help page will tell you that this function is part of the {base} package. As the name suggests, this package is built-in and its functions are ready to use the moment you have installed R. You can verify this by going to the “Packages” tab in RStudio - you will find the base package and it will have a checked box next to it."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#loading-packages",
    "href": "ch/rbasics/firststeps.html#loading-packages",
    "title": "First steps in R",
    "section": "loading packages",
    "text": "loading packages\nWhen looking at the “Packages” tab in RStudio you may notice that some packages are listed, but do not have a check mark in the box next to them. These are packages that are installed, but not loaded. When a package is not loaded, its functions cannot be used. In order to load a package, the default command is library(package_name). This command must be run once every time you open a new R session."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#installing-additional-packages",
    "href": "ch/rbasics/firststeps.html#installing-additional-packages",
    "title": "First steps in R",
    "section": "installing additional packages",
    "text": "installing additional packages\nR really shines because of the ability to install additional packages from external sources. Basically, anyone can create a function, put it in a package and make it available online. Some packages are very sophisticated and popular - e.g. the package ggplot2, which is not built-in, has been downloaded 75 million times. In order to install a package, the default command is install.packages(package_name). Alternatively, you can also click on the “Install” button in the top left of the “Packages” tab and type in the package_name there.\n\n\n\n\n\n\nNote\n\n\n\nA package only needs to be installed once, but\nA package must be loaded every time you open a new R session!\n\n\nHere is a curated list of R packages and tools for different areas."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#footnotes",
    "href": "ch/rbasics/firststeps.html#footnotes",
    "title": "First steps in R",
    "section": "Footnotes",
    "text": "Footnotes\n\nAs long as you are dealing with numbers and calculations. Spaces do matter when we are talking about strings (i.e. text).↩︎"
  }
]